#Список вопросов и ответов
    time fot work - 1,2,3,4,5
++1. Что будет выведено на печать?
class Base{
    private void print{ System.out.println(1); }
}

class Ch extends Base{
    @Override
    private void print{ System.out.println(2); }

    public static void main(){
        Base obj = new Ch();
        ch.print();
    }
}

    /1/ Будет выведено 2.
    Аннотация @Override указывает, что далее мы собираемся переопределять метод базового класса.
    Аннотация служит лишь для контроля успешности действия при сборке проекта.
    В случае отсутствия данной аннотации и не совпадении сигнатур (в результате ошибки) с методом,
    который мы собирались переопределять - случится страшное.
    Очень трудноуловимая ошибка, когда вы думаете, что должно бы переопределяться,
    а по факту имеете отдельный независимый метод, который скорее всего вообще не выполняется.
    При этом компилятор считает, что с его точки зрения все в порядке
    - хотите собственный метод в классе-наследнике - нет проблем. И молчит.

++2. Виды Exceptions. Что такое checked и unchecked? Привести примеры!
    /2/
                        Object
                          |
                   Throwable(CHECKED)
                   /            \
         Error(UNCHECKED)    Exception(CHECKED)
                                |
                      RuntimeException(UNCHECKED)

    1.1 Checked - проверенные, т.к. проверяются перед компиляцией программы, то есть по-любому проверятся.
    #Например, если мы в программе пытаемся считать несуществующий файл, то она выбросил FileNotFoundException.
    Такое можно проверить до компиляции, поэтому и Checked.
    1.2 Exception – это проверенные исключения.
    Это значит, что если метод бросает исключение, которое унаследовано от Exception (напр. IOException), то этот метод должен быть обязательно заключен в блок try-catch.
    Сам метод, который бросает исключение, должен в сигнатуре содержать конструкцию throws.
    Проверенные (checked) исключения означают, что исключение можно было предвидеть и, соответственно,
    оно должно быть обработано, работа приложения должна быть продолжена.
    Пример такого исключения — это попытка создать новый файл, который уже существует (IOException).

    2.1 Unchecked проверить до компиляции нельзя. #Например, у нас есть некое математическое выражение a/(b-c).
    при этом до компиляции неизвестны значения переменных.
    А уже в процессе исполнения программы выяснится, что b = c, и получится, что нужно будет делить "a" на ноль.
    В таком случае вылезет ArithmeticException.
    Но его никак нельзя проверить до исполнения программы, поэтому и unchecked.
    #Еще пример NullPointerException!
    2.2 RuntimeException – это непроверенные исключения.
    Они возникают во время выполнения приложения.
    К таким исключениям относится, например, NullPointerException.
    Они не требуют обязательного заключения в блок try-catch.
    Когда RuntimeException возникает, это свидетельствует о ошибке,
    допущенной программистом (неинициализированный объект, выход за пределы массива и т.д.).
    Поэтому данное исключение не нужно обрабатывать, а нужно исправлять ошибку в коде, чтобы исключение вновь не возникало.

    3.1 Error – критические ошибки, который могут возникнуть в системе (например, StackOverflowError ).
    Как правило обрабатывает их система.
    Если они возникают, то приложение закрывается, так как при данной ситуации работа не может быть продолжена.
    3.2 Из Error'ов стоит знать наиболее общеизвестные, это:
            - OutOfMemoryError (кончилась память)
            - AssertionError (ошибка в условии оператора assert, начиная с Java 1.4)
            - ThreadDeath (кидается в останавливаемом потоке, при вызове у него метода stop()
            - NoSuchMethodError (обычно отсутствует метод main)
            - NoClassDefFoundError (отсутствует код загружаемого класса)

++3. Виды коллекций.
    /3/
    3.1 Интерфейс Collection является самым главным для классов коллекций в библиотеке Java.
    Два основных метода интерфейса.
        - boolean add(E element)
        - Iterator<E> iterator()

    3.2 Коллекции содержат только один элемент в каждой ячейке.
    Список (List) -  где в определенной последовательности хранится группа элементов.
    Множество (Set), в которое можно добавлять только по одному элементу определённого типа.
    Очередь (Queue).

                Interfaces
             /      |       \
    #    Set,      List,     Queue
         |          |           |
      HashSet    ArrayList  PriorityQueue
      TreeSet    Vector     SynchroniseQueue
    LinkedHashSet

    # ArrayList - Механизм автоматического «расширения» массива существует,
    а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().
    #Map не входит в коллекции!

4. Как работают Set, List, Map?
    /4/
    4.1 Set (Множество) - коллекция, которая не может содержать повторяющихся одинаковых элементов, иногда называемая множеством.
    Более формально, коллекция не может содержать пары элементов e1 и e2 таких,
    что выполняется условие e1.equals(e2) и не более одного null элемента

    # При попытке добавлении существующего элемента в LinkedHashSet Коллекция не изменяется
        и все элементы остаются на своих местах.
    # Особое внимание необходимо уделить элементам, которые могут изменяться.
    В поведении Set не указано, что делать если значение элемента Set изменилось таким образом,
    что объект стал равен другому объекту из множества.
    # Некоторые реализации Set имеют ограничения на элементы, которые они могут содержать.
        Например, в некоторых множествах не разрешено добавление null элементов.
        При попытке добавления null в коллекцию обычно происходит unchecked исключение NullPointerException или ClassCastException.

    # HashSet хранит элементы в хеш-таблице, из-за чего имеет наиболее высокую производительность,
        но не гарантирует порядок элементов;
      TreeSet хранит элементы в отсортированном порядке, из-за чего работает существенно медленнее,
        чем HashSet;
      LinkedHashSet отличается от HashSet тем, что хранит элементы в порядке их вставки в коллекцию.
        Эта коллекция лишь немного медленнее HashSet.

    4.2 List


++5. Отличия между LinkedList и ArrayList.
    /5/
    ArrayList - динамический массив, доступ к любому элементу по индексу т.е. О(1).
    O(1) при вставке/удалении в конец. Если при этом не произойдет увеличение массива.
    Недостаток при вставке/удалении в середину в том, что необходимо сдвинуть все элементы вправо/влево.
    Но это моджно сделать быстрее, чем копировать по одному элементу, если использовать native функцию Array.copy().

    LinkedList - двунаправленный связанный список.
    O(1) вставить/удалить элемент из начала/конца так как имеем ссылки на первый и последний элементы.
    До середины нуджно будет итерироваться O(n/2). Но сама вставка элемента O(1).
    В среднем занимает больше памяти из-за того, что каждый элемент хранит ссылку на следующий и предыдущий элемент.

6. Отличия между Set и LinkedList.
    /6/

++7. Что будет, если в Set и List добавить по два одинаковых элемента?
    /7/
    List - элемент добавиться.
    Set - множество не будет изменено.

++8. Отличия между HashMap и и TreeMap. (LinkedHashMap**)
    /8/
    TreeMap — автоматически сортирует помещённые в неё пары. Красно-черное дерево.
    Её стоит использовать там, где важен порядок хранения объектов.

    В HashMap вычисляется хэшкод ключа, вычисляется число по модулю от общего количества корзин.
    В корзину номер которой равен числу опускается значение.

    ║   Property   ║       HashMap       ║      TreeMap      ║     LinkedHashMap   ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║  no guarantee order ║ sorted according  ║                     ║
    ║   Order      ║ will remain constant║ to the natural    ║    insertion-order  ║
    ║              ║      over time      ║    ordering       ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║  Get/put     ║                     ║                   ║                     ║
    ║   remove     ║         O(1)        ║      O(log(n))    ║         O(1)        ║
    ║ containsKey  ║                     ║                   ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║                     ║   NavigableMap    ║                     ║
    ║  Interfaces  ║         Map         ║       Map         ║         Map         ║
    ║              ║                     ║    SortedMap      ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║                     ║                   ║                     ║
    ║     Null     ║       allowed       ║    only values    ║       allowed       ║
    ║ values/keys  ║                     ║                   ║                     ║           ║
    ╠══════════════╬═════════════════════╦═══════════════════╦═════════════════════╣
    ║              ║                     ║                   ║                     ║
    ║Implementation║      buckets        ║   Red-Black Tree  ║    double-linked    ║
    ║              ║                     ║                   ║       buckets



    HashMap - это карта, основанная на хэшировании ключей.
    Он поддерживает операции O (1) get/put.
    Ключи должны иметь последовательные реализации hashCode() и equals(), чтобы это работало.

    LinkedHashMap очень похож на HashMap, но он добавляет осознание в порядок,
        по которому элементы добавляются (или доступны),
        поэтому порядок итерации совпадает с порядком размещения (или порядком доступа, в зависимости от параметров конструкции).

    TreeMap - это отображение на основе дерева.
    Его операции put/get принимают время O (log n).
    Для этого требуется, чтобы элементы имели некоторый механизм сравнения,
        либо со сравнением, либо с компаратором.
    Порядок итераций определяется этим механизмом.


++9. Что нужно сделать, чтобы созданный самим объект использовать в качестве ключа HashMap?
    /9/
    Ключи должны иметь последовательные реализации hashCode() и equals(), чтобы это работало.

++10. Для чего нужно переопределять методы hash и equals?
    /10/
    Чтобы получить правильное значение хэшкода и соответственно положить в правильную корзину.
    Если переопределить используя не все элементы, то хэш будет генерироваться не равномерно.

    А если не переопределить equals, то при изменении значения и попытке заменить его в карте
    мы его не перезапишем.

++11. Как работает try with resources?
    /11/
    Если в блоке try использовать ресурсы реализующие интерфейс AutoClosable,
        то эти ресурсы будут автоматически закрыты в блоке finally!
    И нам не нужно эти ресурсы закрывать специальными командами!


++12. Что вернёт функция и почему?
            public int func(){
                try(){
                    return 1;
                }
                finally{
                    return 2;
                }
            }
    /12/ вернет 2. Finally всегда выполняется!

++13. Что такое String, StringBuffer, StringBuilder?
    /13/
    Класс String является immutable - Вы не можете модифицировать объект String, но можете заменить его созданием нового экземпляра.
    Создание нового экземпляра обходится дороговато.
    Плюсы:
        - использование строк в многопоточных средах (String является потокобезопасным (thread-safe) )
        - использование String Pool (это коллекция ссылок на String объекты, используется для оптимизации памяти)
        - использование строк в качестве ключей в HashMap (ключ рекомендуется делать неизменяемым)
    # java.lang.StringJoiner java 8
        - String hello = "Hello"; String habr = "habrahabr"; String delimiter = ", ";
          System.out.println(String.join(delimiter, hello, habr)); -> "Hello, habrahabr"

    ** CharSequence - это (Interface) читаемая последовательность символов.
    Этот интерфейс обеспечивает единообразный доступ только для чтения ко многим различным типам последовательностей символов.


    Класс StringBuffer представляет расширяемые и доступные для изменений последовательности символов,
      позволяя вставлять символы и подстроки в существующую строку и в любом месте.
    Данный класс гораздо экономичнее в плане потребления памяти.
    Класс StringBuffer является mutable - использовать StringBuffer или StringBuilder следует тогда,
      когда вы хотите модифицировать содержимое.
    StringBuilder был добавлен в 1.5 и он во всем идентичен классу StringBuffer,
      за исключением того, что он не синхронизирован, что делает его значительно шустрее.
    Но цена скорости - небезопасное поведение в многопоточной среде.

++14. Какими способами можно создать и запустить поток?
    /14/
    1 - Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable.
    Этот интерфейс содержит метод run(), который будет выполняться в новом потоке.
    Поток закончит выполнение, когда завершится его метод run().
    2 -  Создать потомка класса Thread и переопределить его метод run().
    Потом вызвать что-то.start().

    #В Java процесс завершается тогда, когда завершается последний его поток.
    Даже если метод main() уже завершился, но еще выполняются порожденные им потоки,
      система будет ждать их завершения.
    Однако это правило не относится к особому виду потоков – демонам.
    Если завершился последний обычный поток процесса, и остались только потоки-демоны,
      то они будут принудительно завершены и выполнение процесса закончится.
    Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод setDaemon(true);
    Проверить, является ли поток демоном, можно вызвав его метод boolean isDaemon();
    


++15. Суть интерфейса Callable.
    /15
    Интерфейс Callable является параметризованным типом,
      с единственным общедоступным методом call().
    Метод call имеет дополнительную возможность возвращать результат,
      а также разрешено выдавать проверенные исключения.
    Результат, полученный в результате задания задачи Callable , доступен для использования через будущее Future.
    Future можно рассматривать как контейнер, который содержит результат вычисления Callable
        public interface Callable<V>{
            V call() throws Exception;
        }
        interface Future<V> {
            V get();
            V get(long timeout, TimeUnit unit);
            boolean cancel(boolean mayInterruptIfRunning);
            boolean isCancelled();
            boolean isDone();
        }
         ExecutorService es = Executors.newSingleThreadExecutor();
         Future<String> result = es.submit(new ComplexCalculator());//ComplexCalculator implements Callable and return String!
         System.out.println("Result of Complex Calculation is : " + result.get());

    Вычисление вызываемого может продолжаться в другом потоке,
      и любая попытка использовать результат Future будет блокировать
      и будет возвращать результат только после его появления.

    Коротко:
    - A Callable должен реализовать метод call(), а Runnable должен реализовать метод run().
    - A Callable может вернуть значение, но Runnable не может.
    - A Callable может выставить проверенное исключение, но Runnable не может.

?? https://habrahabr.ru/post/133413/ пост 2011 года)
??16. Как остановить поток?
    /16/
    16.1 Все потоки нужно прерывать при помощи метода interrupt().
    В самом потоке, который возможно будет прерван -
      нужно устанавливать проверки isInterrupted() во всех ключевых точках (где это необходимо)
      и обрабатывать соответственно.
    16.2 Класс Thread содержит в себе скрытое булево поле, которое называется флагом прерывания.
    Установить этот флаг можно вызвав метод interrupt() потока.
    Проверить же, установлен ли этот флаг, можно двумя способами.
        Первый способ — вызвать метод bool isInterrupted() объекта потока,
        второй — вызвать статический метод bool Thread.interrupted().

    Путь 1. Мы из main выставляем флаг interrupt для потока A.
    Внутри себя поток А проверяет прерван ли он, если да то он завершает свою работу!
    Путь 2. Поток внутри себя ловит InterruptedException,
      если исключение было сгенерировано поток заканчивает работу!
      ** По соглашению любой метод, который прерывает свою выполнение бросая исключение InterruptedException,
      очищает флаг статуса прерывания, когда он бросает это исключение.

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            Занимательно то, что флаг isInterrupted() не заставляет поток остановиться и "умереть".
            Поток может ничего не делать, но продолжать жить дальше!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # В Java (существовали) средства для принудительного завершения потока.
    В частности метод Thread.stop() завершает поток незамедлительно после своего выполнения.
    Однако этот метод, а также Thread.suspend(), приостанавливающий поток, и Thread.resume(),
      продолжающий выполнение потока, были объявлены устаревшими
      и их использование отныне крайне нежелательно.
    Дело в том что поток может быть «убит» во время выполнения операции,
      обрыв которой на полуслове оставит некоторый объект в неправильном состоянии,
      что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке.

++17. Проблемы многопоточности.
    /17/
    Потоки общаются в основном разделяя свои поля и поля объектов между собой.
    Эта форма общения очень эффективна, но делает возможным два типа ошибок:
     1 - вмешательство в поток (thread interference)
     2 - ошибки консистентности памяти (memory consistency errors).
    Для того чтобы предотвратить эти ошибки, нужно использовать синхронизацию потоков.
    Однако синхронизация может привести к
     3 - конкуренции потоков (thread contention), которая возникает,
        когда два или более потока пытаются получить доступ к одному и тому же ресурсу одновременно,
        что приводит к тому, что среда выполнения Java выполняет один или более этих потоков
        более медленно или даже приостанавливает их выполнение.
     3.1 - Голодание (starvation) и 3.2 - активная блокировка (livelock) — это формы конкуренции потоков.

     1 - Вмешательство в поток происходит, когда два действия выполняются разными потоками,
        но используют одни и те же данные.
     2 - Ошибки консистентности памяти (memory consistency errors) возникают,
        когда разные потоки имеют несовместимое представление о том, что должно быть общими данными.
        !! -> Ключ к исключению ошибок консистентности памяти — это понимание связи происходит-до (happens-before).
        Эта связь гарантирует, что данные, записанные в память одной инструкцией, видимы в другой.

        Есть разные способы создания связи происходит-до (happens-before).
        Один из них — это синхронизация.

        Язык программирования Java предоставляет два базовых способа синхронизации:
            11 - синхронизированные методы (synchronized methods)
            22 - синхронизированные инструкции (synchronized statements).
            **НО есть и другие, более сложные, способы синхронизации.
        11 - Чтобы сделать метод синхронизированным, нужно добавить ключевое слово synchronized  к его объявлению.
            **Конструкторы не могут быть синхронизированными.
        22 - Каждый объект имеет внутреннюю блокировку (монитор), который с ним связан.
             Поток владеет блокировкой объекта между временем получения и временем освобождения блокировки.
             **Возможность потоков получать одну и ту же блокировку несколько раз
              называется повторная синхронизация (reentrant synchronization).

     Атомарное действие — это действие которое происходит полностью и сразу.
      - Чтения и запись атомарны для ссылочных переменных и примитивных типов(кроме long  и double )
      - Чтение и запись атомарны для всех переменных, объявленных как volatile  (включая long  и double ).

     --Взаимная блокировка (deadlock)-- описывает ситуацию,
      когда два или более потока блокируются навсегда, каждый ожидая другого.

     --Голодание (starvation)-- описывает ситуацию,когда поток не может получить доступ к
      совместно используемым ресурсам и не может продвинуться в своём выполнении дальше.

     --Активная блокировка (livelock)--
      Как и взаимная блокировка (deadlock), активно заблокированные потоки не могут продвинуться дальше.
      Однако эти потоки не заблокированы — они просто слишком заняты, отвечая друг другу,
       чтобы вернуться к работе.

     --Guarded blocks--
      Наиболее часто используемый способ согласования — защищённые блокировки (guarded blocks).
      Такой блок начинается с выбора условия, которое должно быть true,
        перед тем как может осуществиться блокировка.
      **Наиболее эффективно использовать Object.wait(), чтобы приостановить работу текущего потока,
        если какое-то условие еще не наступило.
            ####Мы ждем чтобы joy стало true и мы прошли цикл while и выполнили то что хотим!!
            while(!joy) {
                    try {
                        wait();
                    } catch (InterruptedException e) {}
            }
            ...код который должен работать
            ####
      **Чтобы выпустить поток из этого состояния нужно вызвать notifyAll();

      --Неизменяемые объекты (immutable objects)--
      Неизменяемые объекты особенно полезны в многопоточных приложениях.
      Так как они не могут менять своего внутреннего состояния,
       то они не могут быть испорчены вмешательством в поток (thread interference)
       или прочитаны в некорректном состоянии.
      Чтобы класс был immutable:
          a. Не создавайте setter-ов.
          б. Делайте все поля final  и private.

      --Объекты Lock--
      Высокоуровневое API java.util.concurrent.locks.
      Преимущество их над внутренними блок-ми в том,
       что они могут отказаться от участия в попытке приобрести блокировку.

      **Executors
            - java.util.concurrent.Executor
            - java.util.concurrent.ExecutorService
            - java.util.concurrent.ScheduledExecutorService
            -Poll потоков
                -java.util.concurrent.ThreadPoolExecutor
                - java.util.concurrent.ScheduleThreadPoolExecutor.
      Fork/Join Framework

      **Fork/Join Framework является реализацией интерфейса ExecutorService,
        который помогает вам получить преимущество при использовании мультипроцессорной системы.

      **Атомарные переменные
      Пакет java.util.concurrent.atomic содержит классы,
        которые поддерживают атомарные операции над простыми переменными.
      !#! Замена int на AtomicInteger
        позволит защититься от вмешательства в поток (thread interference) без synchronized.


++18. Какие приходилось решать задачи с многопоточностью?
    /18/
    Сортировка массива произвольным числом потоков

++19. Для чего служит модификатор volatile?
    /19/
    Ключевое слово volatile необходимо использовать для переменных, которые используются разными потоками.
    Это связано с тем, что значение переменной, объявленной без volatile,
      может кэшироваться отдельно для каждого потока,
      и значение из этого кэша может различаться для каждого из них.
    Объявление переменной с ключевым словом volatile отключает для неё такое кэширование
      и все запросы к переменной будут направляться непосредственно в память.

++20. Написать реализацию синглтона с синхронизированной инициализацией.
    /20/
    20.1
    public class Singleton {
    	private static Singleton instance;
        !!!!!!!!
        private Singleton(){}

    	public ! static ! synchronized Singleton getInstance() {
    		if (instance == null) {
    			instance = new Singleton();
    		}
    		return instance;
    	}
    }
    Синхронизация полезна только один раз, при первом обращении к getInstance(),
     после этого каждый раз, при обращении этому методу, синхронизация просто забирает время.
    ** use: Singleton my = Singleton.getInstance();!!!!

    20.2
    public enum Singleton {
    	INSTANCE;
    }
    20.3
    public class Singleton {
    	public static final Singleton INSTANCE = new Singleton();
    }
    *Потеряем ленивую инициализация(Объект instance будет создан classloader-ом во время инициализации класса)

    20.4
     public class Singleton {
        	private static !volatile! Singleton instance;
            private Singleton(){}

        	public static Singleton getInstance() {
        	    if (instance == null)
        	        synchronized (Singleton.class){
        		        if (instance == null)
        			        instance = new Singleton();
        		    }
        		return instance;
        	}
        }

    Не смотря на то, что этот вариант выглядит как идеальное решение,
     использовать его не рекомендуется т.к. товарищ Allen Holub заметил,что использование
     volatile модификатора может привести к проблемам производительности на мультипроцессорных системах.


++21. Как создать servlet?
    /21/
    21.1<dependency>
           <groupId>javax.servlet</groupId>
           <artifactId>javax.servlet-api</artifactId>
           <version>3.1.0</version>
        </dependency>

    22.2
    Создаем класс MainServlet.java и наследуем его от HttpServlet и
      переопределяем два метода void doGet(…) и void doPost(…).
    **Известно, что HTTP протокол имеет 7 методов передачи данных:
      — DELETE — HEAD — GET — OPTIONS — POST — PUT — TRACE

    22.3.1
    Теперь создаем папку src/main/webapp/WEB-INF,
      а там создаем файл web.xml в этом файле мы зарегистрируем наш сервлет и замапим его на URL.

    22.3.2
    @WebServlet("/")
    Данная аннотация регистрирует сервлет в контексте приложения,
      это тоже самое что мы делали в web.xml.

22. С какими модулями спринга работал?
    /22/

23. Как в спринге создать свой контроллер?
    /23/

24. Суть MVC.
    /24/
    Паттерн Model — View — Controller (Модель — Вид — Контроллер) при помощи слабо связанных
     готовых компонентов.
    Паттерн MVC разделяет аспекты приложения (логику ввода, бизнес-логику и логику UI),
     обеспечивая при этом свободную связь между ними.
    - Model инкапсулирует (объединяет) данные приложения, в целом они будут состоять из объектовили бинов).
    - View отвечает за отображение данных Модели — генерируя HTML, которые мы видим в своём браузере.
    - Controller обрабатывает запрос пользователя, создаёт соответствующую Модель и передаёт её для отображения в Вид.


25. Есть две таблицы. Написать для Hibernate класс, на который будут мапиться данные из
таблицы book
       table autor (id, fio) ; table book(id, title, author_id)
    /25/


26. С какой версией спринга работал?
    /26/

27. Что такое Bean? Чем отличается от других объектов?
    /27/

28. Какими способами можно объявить Bean в спринге?
    /28/

++29. В чём суть IoC?
    /29/
    Inversion of control - не я вызываю функцию, а мой класс вызывает framework!

++30. В чём суть DI?
    /30/
    dependency injection - обьект моего класса встраивается/внедряется туда куда надо =)!

31. Как реализуется внедрение зависимостей?
    /31/

32. Есть два бина от одного интерфейса. Как конкретизировать, какой бин нужно инжектить?
    /32/

++33. Что такое DispatcherServlet в спринге?
    /33/
    Вся логика работы Spring MVC построена вокруг DispatcherServlet,
     который принимает и обрабатывает все HTTP-запросы (из UI) и ответы на них.

    *****
    -После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping,
      который определяет, какой Контроллер должен быть вызван, после чего, отправляет запрос в нужный Контроллер.
    -Контроллер принимает запрос и вызывает соответствующий служебный метод, основанный на GET или POST.
     Вызванный метод определяет данные Модели, основанные на определённой бизнес-логике и
      возвращает в DispatcherServlet имя Вида (View).
    -При помощи интерфейса ViewResolver DispatcherServlet определяет,
      какой Вид нужно использовать на основании полученного имени.
    -После того, как Вид (View) создан, DispatcherServlet отправляет данные Модели в виде атрибутов в Вид,
      который в конечном итоге отображается в браузере.

    Все вышеупомянутые компоненты, а именно, HandlerMapping, Controller и ViewResolver,
     являются частями интерфейса WebApplicationContext extends ApplicationContext,
     с некоторыми дополнительными особенностями, необходимыми для создания web-приложений.


++34. Что такое servlet?
    /34/
    Расширение возможностей сервера.
    Это Java программа, которая выполняется WEB-сервром или сервером приложений (Application Server)
      и реализует интерфейс javax.servlet.Servlet.
    Это класс, расширяющий HttpServlet, у которого есть два главных метода
      void doGet(HttpServletRequest request, HttpServletResponse response){}
      void doPost(HttpServletRequest request, HttpServletResponse response){}

    ***
    Для запуска сервлетов используется Web-сервер со специальным модулем (контейнером сервлетов)
    ***

++35. С какими технологиями хотелось бы работать, что-то новое изучить?
    /35/
    Может быть Kotlin!

    ???????
    На самом деле не знаю!!

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++_Мои_вопросы_+++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

++1. Размер объекта?
    /1/
    Зависит от
        - версии java
        - Издателя
        - Разрядность ОС
        - Параметров запуска JVM

    Header - 8 байт *у массисва 12
        - MarkWord (hash, age) ?????__Max hash много меньше 2^31__?????
        - Klass pointer
        - *size
    Примитивные типы
    Ссылки на другое объекты
    Гранулярность


++2. GC его работа, какие GC знаешь?
    /2/
    Есть понятие достижимого и не достижимого объекта!
    Reference, static переменные, классы и потоки - это root nodes(rn).
    Rn расположены в стеке. Они указавают на обьекты, которые расположены в heap.
    Если обьект в heap есть, то это достижиный rn.

    Есть young и old(tenured) области.
    Young делиться на eden(все объекты появляются здесь), survivor0 и survivor1.
    Работа GC в этой области называется - Minor GC. Major GC - это работа в области old.
    При Minor GC анализируется eden область и достижимые объекты, перемещаются в survivor0.
    При этом считает что eden свободен и его можно снова заполнять.
    Долгоживущие объекты перемещаюся в survivor1.Объект переживший 8(храниться в header об.) Minor GC,
     перемещается в tenured область.

    Young GC:             Old GC: #имеют разные алгоритмы работ
        - Copy          - MarkSweepCompact - самый простой однопоточный
        - PS Scavenge   - PS MarkSweep  - use мало ресурсов, но пауза Stop-the-word(STW) будет большим!
        - PerNew        - ConcurrentMarkSweep - use много ресурсов, но старается свести к min паузу STW.
    ** G1 не имеет разделения на Young GC, Old GC у него особый алгоритм. Он нарезает память на куски.
       У него может быть 4(и болле) области под eden, survivor и tenured.

++3. Раскажи про настройку памяти для приложения?
    /3/
    Должно быть Xms=Xmx (минимальный = максимальный размер памяти)
    MetaSpace тоже можно ограничивать. Тут храниться метаинформация!

??4. Магия kill -3 %p
    /4/
    Полезно иметь возможность при каком-то событии(#OutOfMemoryError) сделать так что бы при
        возникновении этого собятия приложение писало в лог свое текущее состояние.
    Для этого нужно при старте примложения написать -XX:(необходимое событие)(#onOutOfMemoryError)="kill -3 %p"

    *Thread dump

     dump всех потоков в stdout:
     windows: CTRL-Break в консоле, где запущено приложение
     unix: kill -3 PID


++5. JavaManagementExtended(JMX) и ManagementBean(MBean)
    /5/
    Объект в программе нужно обернуть в MBean, и при помощи jconsole и JMX
      в runtime смотреть состояние приложения.

++6.Какие classLoader ты знаешь?
    /6/
    Их 3
    1. BootStrap
    2. Extension
    3. Class path

7.  Зачем они нужны?

++8. Что такое контейнер сервлетов?
    /8/
    Контейнер сервлетов  — программа, представляющая собой сервер, который занимается системной поддержкой
     сервлетов и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях. Может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений.
    Так же он обеспечивает обмен данными между сервлетом и клиентами,
     берёт на себя выполнение таких функций, как создание программной среды для функционирующего сервлета,
     идентификацию и авторизацию клиентов, организацию сессии для каждого из них.

9. Основные элементы Spring?
    /9/
        - ApplicationContext

++10. Что может победить finally?
    /10/
    *finally может “съесть” любой эксепшн
          public static int f() {
                try {
                    throw new RuntimeException();
                } finally {
                    return 0;
                }
          }
    внернет 0!

    Победить finally может только System.exit(..).

    Это для Петра!
    !!!!Написать тест!
