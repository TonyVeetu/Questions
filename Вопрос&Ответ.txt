#Список вопросов и ответов
    time fot work - 1,2,3,4,5
++1. Что будет выведено на печать?
class Base{
    private void print{ System.out.println(1); }
}

class Ch extends Base{
    @Override
    private void print{ System.out.println(2); }

    public static void main(){
        Base obj = new Ch();
        ch.print();
    }
}

    /1/ Будет выведено 2.
    Аннотация @Override указывает, что далее мы собираемся переопределять метод базового класса.
    Аннотация служит лишь для контроля успешности действия при сборке проекта.
    В случае отсутствия данной аннотации и не совпадении сигнатур (в результате ошибки) с методом,
    который мы собирались переопределять - случится страшное.
    Очень трудноуловимая ошибка, когда вы думаете, что должно бы переопределяться,
    а по факту имеете отдельный независимый метод, который скорее всего вообще не выполняется.
    При этом компилятор считает, что с его точки зрения все в порядке
    - хотите собственный метод в классе-наследнике - нет проблем. И молчит.

++2. Виды Exceptions. Что такое checked и unchecked? Привести примеры!
    /2/
                        Object
                          |
                   Throwable(CHECKED)
                   /            \
         Error(UNCHECKED)    Exception(CHECKED)
                                |
                      RuntimeException(UNCHECKED)

    1.1 Checked - проверенные, т.к. проверяются перед компиляцией программы, то есть по-любому проверятся.
    #Например, если мы в программе пытаемся считать несуществующий файл, то она выбросил FileNotFoundException.
    Такое можно проверить до компиляции, поэтому и Checked.
    1.2 Exception – это проверенные исключения.
    Это значит, что если метод бросает исключение, которое унаследовано от Exception (напр. IOException), то этот метод должен быть обязательно заключен в блок try-catch.
    Сам метод, который бросает исключение, должен в сигнатуре содержать конструкцию throws.
    Проверенные (checked) исключения означают, что исключение можно было предвидеть и, соответственно,
    оно должно быть обработано, работа приложения должна быть продолжена.
    Пример такого исключения — это попытка создать новый файл, который уже существует (IOException).

    2.1 Unchecked проверить до компиляции нельзя. #Например, у нас есть некое математическое выражение a/(b-c).
    при этом до компиляции неизвестны значения переменных.
    А уже в процессе исполнения программы выяснится, что b = c, и получится, что нужно будет делить "a" на ноль.
    В таком случае вылезет ArithmeticException.
    Но его никак нельзя проверить до исполнения программы, поэтому и unchecked.
    #Еще пример NullPointerException!
    2.2 RuntimeException – это непроверенные исключения.
    Они возникают во время выполнения приложения.
    К таким исключениям относится, например, NullPointerException.
    Они не требуют обязательного заключения в блок try-catch.
    Когда RuntimeException возникает, это свидетельствует о ошибке,
    допущенной программистом (неинициализированный объект, выход за пределы массива и т.д.).
    Поэтому данное исключение не нужно обрабатывать, а нужно исправлять ошибку в коде, чтобы исключение вновь не возникало.

    3.1 Error – критические ошибки, который могут возникнуть в системе (например, StackOverflowError ).
    Как правило обрабатывает их система.
    Если они возникают, то приложение закрывается, так как при данной ситуации работа не может быть продолжена.
    3.2 Из Error'ов стоит знать наиболее общеизвестные, это:
            - OutOfMemoryError (кончилась память)
            - AssertionError (ошибка в условии оператора assert, начиная с Java 1.4)
            - ThreadDeath (кидается в останавливаемом потоке, при вызове у него метода stop()
            - NoSuchMethodError (обычно отсутствует метод main)
            - NoClassDefFoundError (отсутствует код загружаемого класса)

++3. Виды коллекций.
    /3/
    3.1 Интерфейс Collection является самым главным для классов коллекций в библиотеке Java.
    Два основных метода интерфейса.
        - boolean add(E element)
        - Iterator<E> iterator()

    3.2 Коллекции содержат только один элемент в каждой ячейке.
    Список (List) -  где в определенной последовательности хранится группа элементов.
    Множество (Set), в которое можно добавлять только по одному элементу определённого типа.
    Очередь (Queue).

                Interfaces
             /      |       \
    #    Set,      List,     Queue
         |          |           |
      HashSet    ArrayList  PriorityQueue
      TreeSet    Vector     SynchroniseQueue
    LinkedHashSet

    # ArrayList - Механизм автоматического «расширения» массива существует,
    а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().
    #Map не входит в коллекции!

4. Как работают Set, List, Map?
    /4/
    4.1 Set (Множество) - коллекция, которая не может содержать повторяющихся одинаковых элементов, иногда называемая множеством.
    Более формально, коллекция не может содержать пары элементов e1 и e2 таких,
    что выполняется условие e1.equals(e2) и не более одного null элемента

    # При попытке добавлении существующего элемента в LinkedHashSet Коллекция не изменяется
        и все элементы остаются на своих местах.
    # Особое внимание необходимо уделить элементам, которые могут изменяться.
    В поведении Set не указано, что делать если значение элемента Set изменилось таким образом,
    что объект стал равен другому объекту из множества.
    # Некоторые реализации Set имеют ограничения на элементы, которые они могут содержать.
        Например, в некоторых множествах не разрешено добавление null элементов.
        При попытке добавления null в коллекцию обычно происходит unchecked исключение NullPointerException или ClassCastException.

    # HashSet хранит элементы в хеш-таблице, из-за чего имеет наиболее высокую производительность,
        но не гарантирует порядок элементов;
      TreeSet хранит элементы в отсортированном порядке, из-за чего работает существенно медленнее,
        чем HashSet;
      LinkedHashSet отличается от HashSet тем, что хранит элементы в порядке их вставки в коллекцию.
        Эта коллекция лишь немного медленнее HashSet.

    4.2 List


++5. Отличия между LinkedList и ArrayList.
    /5/
    ArrayList - динамический массив, доступ к любому элементу по индексу т.е. О(1).
    O(1) при вставке/удалении в конец. Если при этом не произойдет увеличение массива.
    Недостаток при вставке/удалении в середину в том, что необходимо сдвинуть все элементы вправо/влево.
    Но это моджно сделать быстрее, чем копировать по одному элементу, если использовать native функцию Array.copy().

    LinkedList - двунаправленный связанный список.
    O(1) вставить/удалить элемент из начала/конца так как имеем ссылки на первый и последний элементы.
    До середины нуджно будет итерироваться O(n/2). Но сама вставка элемента O(1).
    В среднем занимает больше памяти из-за того, что каждый элемент хранит ссылку на следующий и предыдущий элемент.

6. Отличия между Set и LinkedList.
    /6/

++7. Что будет, если в Set и List добавить по два одинаковых элемента?
    /7/
    List - элемент добавиться.
    Set - множество не будет изменено.

++8. Отличия между HashMap и и TreeMap. (LinkedHashMap**)
    /8/
    TreeMap — автоматически сортирует помещённые в неё пары. Красно-черное дерево.
    Её стоит использовать там, где важен порядок хранения объектов.

    В HashMap вычисляется хэшкод ключа, вычисляется число по модулю от общего количества корзин.
    В корзину номер которой равен числу опускается значение.

    ║   Property   ║       HashMap       ║      TreeMap      ║     LinkedHashMap   ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║  no guarantee order ║ sorted according  ║                     ║
    ║   Order      ║ will remain constant║ to the natural    ║    insertion-order  ║
    ║              ║      over time      ║    ordering       ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║  Get/put     ║                     ║                   ║                     ║
    ║   remove     ║         O(1)        ║      O(log(n))    ║         O(1)        ║
    ║ containsKey  ║                     ║                   ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║                     ║   NavigableMap    ║                     ║
    ║  Interfaces  ║         Map         ║       Map         ║         Map         ║
    ║              ║                     ║    SortedMap      ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║                     ║                   ║                     ║
    ║     Null     ║       allowed       ║    only values    ║       allowed       ║
    ║ values/keys  ║                     ║                   ║                     ║           ║
    ╠══════════════╬═════════════════════╦═══════════════════╦═════════════════════╣
    ║              ║                     ║                   ║                     ║
    ║Implementation║      buckets        ║   Red-Black Tree  ║    double-linked    ║
    ║              ║                     ║                   ║       buckets



    HashMap - это карта, основанная на хэшировании ключей.
    Он поддерживает операции O (1) get/put.
    Ключи должны иметь последовательные реализации hashCode() и equals(), чтобы это работало.

    LinkedHashMap очень похож на HashMap, но он добавляет осознание в порядок,
        по которому элементы добавляются (или доступны),
        поэтому порядок итерации совпадает с порядком размещения (или порядком доступа, в зависимости от параметров конструкции).

    TreeMap - это отображение на основе дерева.
    Его операции put/get принимают время O (log n).
    Для этого требуется, чтобы элементы имели некоторый механизм сравнения,
        либо со сравнением, либо с компаратором.
    Порядок итераций определяется этим механизмом.


++9. Что нужно сделать, чтобы созданный самим объект использовать в качестве ключа HashMap?
    /9/
    Ключи должны иметь последовательные реализации hashCode() и equals(), чтобы это работало.

++10. Для чего нужно переопределять методы hash и equals?
    /10/
    Чтобы получить правильное значение хэшкода и соответственно положить в правильную корзину.
    Если переопределить используя не все элементы, то хэш будет генерироваться не равномерно.

    А если не переопределить equals, то при изменении значения и попытке заменить его в карте
    мы его не перезапишем.

++11. Как работает try with resources?
    /11/
    Если в блоке try использовать ресурсы реализующие интерфейс AutoClosable,
        то эти ресурсы будут автоматически закрыты в блоке finally!
    И нам не нужно эти ресурсы закрывать специальными командами!


++12. Что вернёт функция и почему?
            public int func(){
                try(){
                    return 1;
                }
                finally{
                    return 2;
                }
            }
    /12/ вернет 2. Finally всегда выполняется!

13. Что такое String, StringBuffer, StringBuilder?
14. Какими способами можно создать и запустить поток?
15. Суть интерфейса Callable.
16. Как остановить поток?
17. Проблемы многопоточности.
18. Какие приходилось решать задачи с многопоточностью?
19. Для чего служит модификатор volatile?
20. Написать реализацию синглтона с синхронизированной инициализацией.
21. Как создать servlet?
22. С какими модулями спринга работал?
23. Как в спринге создать свой контроллер?
24. Суть MVC.
25. Есть две таблицы. Написать для Hibernate класс, на который будут мапиться данные из
таблицы book
       table autor (id, fio) ; table book(id, title, author_id)

26. С какой версией спринга работал?
27. Что такое Bean? Чем отличается от других объектов?
28. Какими способами можно объявить Bean в спринге?
29. В чём суть IoC?
30. В чём суть DI?
31. Как реализуется внедрение зависимостей?
32. Есть два бина от одного интерфейса. Как конкретизировать, какой бин нужно инжектить?
33. Что такое DispatcherServlet в спринге?
34. Что такое servlet?
35. С какими технологиями хотелось бы работать, что-то новое изучить?


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++_Мои_вопросы_+++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

1. Размер объекта?
2. GC его работа?
    /2/ понятие достижимого и не достижимого объекта!

3. Какие classLoader ты знаешь?