#Список вопросов и ответов
    time fot work - 1,2,3,4,5
++1. Что будет выведено на печать?
    class Base{
        private void print{ System.out.println(1); }
    }

    class Ch extends Base{
        @Override
        private void print{ System.out.println(2); }

        public static void main(){
            Base obj = new Ch();
            ch.print();
        }
    }

    /1/ Будет выведено 2.
    Аннотация @Override указывает, что далее мы собираемся переопределять метод базового класса.
    Аннотация служит лишь для контроля успешности действия при сборке проекта.
    В случае отсутствия данной аннотации и не совпадении сигнатур (в результате ошибки) с методом,
    который мы собирались переопределять - случится страшное.
    Очень трудноуловимая ошибка, когда вы думаете, что должно бы переопределяться,
    а по факту имеете отдельный независимый метод, который скорее всего вообще не выполняется.
    При этом компилятор считает, что с его точки зрения все в порядке
    - хотите собственный метод в классе-наследнике - нет проблем. И молчит.

++2. Виды Exceptions. Что такое checked и unchecked? Привести примеры!
    /2/
                        Object
                          |
                   Throwable(CHECKED)
                   /            \
         Error(UNCHECKED)    Exception(CHECKED)
                                |
                      RuntimeException(UNCHECKED)

    1.1 Checked - проверенные, т.к. проверяются перед компиляцией программы, то есть по-любому проверятся.
    #Например, если мы в программе пытаемся считать несуществующий файл, то она выбросил FileNotFoundException.
    Такое можно проверить до компиляции, поэтому и Checked.
    1.2 Exception – это проверенные исключения.
    Это значит, что если метод бросает исключение, которое унаследовано от Exception (напр. IOException),
        то этот метод должен быть обязательно заключен в блок try-catch.
    Сам метод, который бросает исключение, должен в сигнатуре содержать конструкцию throws.
    Проверенные (checked) исключения означают, что исключение можно было предвидеть и, соответственно,
    оно должно быть обработано, работа приложения должна быть продолжена.
    Пример такого исключения — это попытка создать новый файл, который уже существует (IOException).

    2.1 Unchecked проверить до компиляции нельзя. #Например, у нас есть некое математическое выражение a/(b-c).
    при этом до компиляции неизвестны значения переменных.
    А уже в процессе исполнения программы выяснится, что b = c, и получится, что нужно будет делить "a" на ноль.
    В таком случае вылезет ArithmeticException.
    Но его никак нельзя проверить до исполнения программы, поэтому и unchecked.
    #Еще пример NullPointerException!
    2.2 RuntimeException – это непроверенные исключения.
    Они возникают во время выполнения приложения.
    К таким исключениям относится, например, NullPointerException.
    Они не требуют обязательного заключения в блок try-catch.
    Когда RuntimeException возникает, это свидетельствует о ошибке,
    допущенной программистом (неинициализированный объект, выход за пределы массива и т.д.).
    Поэтому данное исключение не нужно обрабатывать, а нужно исправлять ошибку в коде, чтобы исключение вновь не возникало.

    3.1 Error – критические ошибки, который могут возникнуть в системе (например, StackOverflowError ).
    Как правило обрабатывает их система.
    Если они возникают, то приложение закрывается, так как при данной ситуации работа не может быть продолжена.
    3.2 Из Error'ов стоит знать наиболее общеизвестные, это:
            - OutOfMemoryError (кончилась память)
            - AssertionError (ошибка в условии оператора assert, начиная с Java 1.4)
            - ThreadDeath (кидается в останавливаемом потоке, при вызове у него метода stop()
            - NoSuchMethodError (обычно отсутствует метод main)
            - NoClassDefFoundError (отсутствует код загружаемого класса)

++3. Виды коллекций.
    /3/
    3.1 Интерфейс Collection является самым главным для классов коллекций в библиотеке Java.
    Два основных метода интерфейса.
        - boolean add(E element)
        - Iterator<E> iterator()

    3.2 Коллекции содержат только один элемент в каждой ячейке.
    Список (List) -  где в определенной последовательности хранится группа элементов.
    Множество (Set), в которое можно добавлять только по одному элементу определённого типа.
    Очередь (Queue) - очереди FIFO (first-in-first-out).
      |_ Deque -  Deque ("дек", Double Ended Queue) - это линейная коллекция, поддерживающая вставку/извлечение элементов
            с обоих концов. Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO.

                        Interfaces(I)
                        /            \
                Collection            Map
             /      |       \
    #    Set(I)   List(I)   Queue(I) - Deque(I)----------------
         |          |           |              \               |
      HashSet    ArrayList  PriorityQueue     ArrayDeque       |
      TreeSet    Vector     SynchroniseQueue                   |
   LinkedHashSet  Stack                                        |
                LinkedList ------------------------------------

   # LinkedList - двунаправленный связанный список!

   # ArrayList - Механизм автоматического «расширения» массива существует,
     а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().
    #Map не входит в коллекции!

++4. Как работают Set, List, Map?
    /4/
    4.1 Set (Множество) - коллекция, которая не может содержать повторяющихся одинаковых элементов,
      иногда называемая множеством, порядка нет.
    Более формально, коллекция не может содержать пары элементов e1 и e2 таких,
    что выполняется условие e1.equals(e2) и не более одного null элемента.

    # При попытке добавлении существующего элемента в LinkedHashSet Коллекция не изменяется
        и все элементы остаются на своих местах.
    !!! Особое внимание необходимо уделить элементам, которые могут изменяться.
    В поведении Set не указано, что делать если значение элемента Set изменилось таким образом,
     что объект стал равен другому объекту из множества.
    # Некоторые реализации Set имеют ограничения на элементы, которые они могут содержать.
        Например, в некоторых множествах не разрешено добавление null элементов.
        При попытке добавления null в коллекцию обычно
         происходит unchecked исключение NullPointerException или ClassCastException.

    # HashSet хранит элементы в хеш-таблице, из-за чего имеет наиболее высокую производительность,
        но не гарантирует порядок элементов;
      TreeSet хранит элементы в отсортированном порядке, из-за чего работает существенно медленнее,
        чем HashSet;
      LinkedHashSet отличается от HashSet тем, что хранит элементы в порядке их вставки в коллекцию.
        Эта коллекция лишь немного медленнее HashSet.

    4.2 List - представляет собой упорядоченный набор элементов и может содержать повторяющиеся элементы.
        Динамически может менять размер массива.

    #List<String> coolStringList = Arrays.asList("Java", "Scala", "Groovy");

            Collection
            /         \
      __List(I)_       Queue(I) - FIFO
     |          |           |
  Vector        |        Deque(I) - двухконцевая очередь
     |          |           \
   Stack     ___|______      \
            |          |      |
         ArrayList  LinkedList

   4.3 Map - является объектом, который содержит ключи и значения.
    Map не может содержать дубли ключей: Каждый ключ может иметь только одно значение.
    # HashMap, TreeMap и LinkedHashMap.
    # TreeMap представляет собой красно-черное дерево, основанное на NavigableMap.
      Map сортируются с помощью компаратора.
      log(n) время выполнения для containsKey, get, put и remove.
!!!!!
   TreeSet - NavigableSet на основе TreeMap. Элементы могут быть упорядочены в порядке их добавления или с помощью компаратора.
    Эта реализация обеспечивает log(n) время выполнения для основных операций (add, remove и contains).
!!!!!


++5. Отличия между LinkedList и ArrayList.
    /5/
    ArrayList - динамический массив, доступ к любому элементу по индексу т.е. О(1).
    O(1) при вставке/удалении в конец. Если при этом не произойдет увеличение массива.
    Недостаток при вставке/удалении в середину в том, что необходимо сдвинуть все элементы вправо/влево.
    Но это моджно сделать быстрее, чем копировать по одному элементу, если использовать native функцию Array.copy().

    LinkedList - двунаправленный связанный список.
    O(1) вставить/удалить элемент из начала/конца так как имеем ссылки на первый и последний элементы.
    До середины нужно будет итерироваться O(n/2). Но сама вставка элемента O(1).
    В среднем занимает больше памяти из-за того, что каждый элемент хранит ссылку на следующий и предыдущий элемент.

++6. Отличия между Set и LinkedList.
    /6/
    Есть порядок и могут быть повторения.
    В Set наоборот.

++7. Что будет, если в Set и List добавить по два одинаковых элемента?
    /7/
    List - элемент добавиться.
    Set - множество не будет изменено.

++8. Отличия между HashMap и и TreeMap. (LinkedHashMap**)
    /8/
    !-->> HashSet на основе HashMap <<---!
    TreeMap — автоматически сортирует помещённые в неё пары. Красно-черное дерево.
    Её стоит использовать там, где важен порядок хранения объектов.

    В HashMap вычисляется хэшкод ключа, вычисляется число по модулю от общего количества корзин.
    В корзину номер которой равен числу опускается значение.

    ║   Property   ║       HashMap       ║      TreeMap      ║     LinkedHashMap   ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║  no guarantee order ║ sorted according  ║                     ║
    ║   Order      ║ will remain constant║ to the natural    ║    insertion-order  ║
    ║              ║      over time      ║    ordering       ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║  Get/put     ║                     ║                   ║                     ║
    ║   remove     ║         O(1)        ║      O(log(n))    ║         O(1)        ║
    ║ containsKey  ║                     ║                   ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║                     ║   NavigableMap    ║                     ║
    ║  Interfaces  ║         Map         ║       Map         ║         Map         ║
    ║              ║                     ║    SortedMap      ║                     ║
    ╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
    ║              ║                     ║                   ║                     ║
    ║     Null     ║       allowed       ║    only values    ║       allowed       ║
    ║ values/keys  ║                     ║                   ║                     ║           ║
    ╠══════════════╬═════════════════════╦═══════════════════╦═════════════════════╣
    ║              ║                     ║                   ║                     ║
    ║Implementation║      buckets        ║   Red-Black Tree  ║    double-linked    ║
    ║              ║                     ║                   ║       buckets

    HashMap - это карта, основанная на хэшировании ключей.
    Ключи должны иметь последовательные реализации hashCode() и equals(), чтобы это работало.

    LinkedHashMap очень похож на HashMap, но он добавляет осознание в порядок,
        по которому элементы добавляются (или доступны),
        поэтому порядок итерации совпадает с порядком размещения (или порядком доступа, в зависимости от параметров конструкции).

    TreeMap - это отображение на основе дерева.
    Для этого требуется, чтобы элементы имели некоторый механизм сравнения,
        либо со сравнением, либо с компаратором.
!!!!!!!!!!!
!!!!Любая реализация с Tree имеет в своем распоряжение дерево  место массива!
!!!!!!!!!!!

++9. Что нужно сделать, чтобы созданный самим объект использовать в качестве ключа HashMap?
    /9/
    Ключи должны иметь последовательные реализации hashCode() и equals(), чтобы это работало.

++10. Для чего нужно переопределять методы hashCode и equals?
    /10/
    Чтобы получить правильное значение хэшкода.

    В классе  Object equals() равен оператору ==. Это значит что сравнивается адреса памяти, а не содержимое объектов!
    Что бы этого избежать в #HashSet нужно переопределить equals().

++11. Как работает try with resources?
    /11/
    Если в блоке try использовать ресурсы реализующие интерфейс AutoClosable,
        то эти ресурсы будут автоматически закрыты в блоке finally!
    И нам не нужно эти ресурсы закрывать специальными командами!

++12. Что вернёт функция и почему?
            public int func(){
                try(){
                    return 1;
                }
                finally{
                    return 2;
                }
            }
    /12/ вернет 2. Finally всегда выполняется! but -≥ System.exit();

++13. Что такое String, StringBuffer, StringBuilder?
    /13/
    StringBuilder - шустрее, но потоконебезопасный!
    Класс String является immutable - Вы не можете модифицировать объект String,
        но можете заменить его созданием нового экземпляра.
    Создание нового экземпляра обходится дороговато.
    Плюсы:
        - использование строк в многопоточных средах (String является потокобезопасным (thread-safe) )
        - использование String Pool (это коллекция ссылок на String объекты, используется для оптимизации памяти)
        - использование строк в качестве ключей в HashMap (ключ рекомендуется делать неизменяемым)
    # java.lang.StringJoiner java 8
        - String hello = "Hello"; String habr = "habrahabr"; String delimiter = ", ";
          System.out.println(String.join(delimiter, hello, habr)); -> "Hello, habrahabr"

    ** CharSequence - это (Interface) читаемая последовательность символов.
    Этот интерфейс обеспечивает единообразный доступ только для чтения
        ко многим различным типам последовательностей символов.

    Класс StringBuffer представляет расширяемые и доступные для изменений последовательности символов,
        позволяя вставлять символы и подстроки в существующую строку и в любом месте.
    Данный класс гораздо экономичнее в плане потребления памяти.
    Класс StringBuffer является mutable - использовать StringBuffer или StringBuilder следует тогда,
      когда вы хотите модифицировать содержимое.
    StringBuilder был добавлен в 1.5 и он во всем идентичен классу StringBuffer,
      за исключением того, что он не синхронизирован, что делает его значительно шустрее.
    Но цена скорости - небезопасное поведение в многопоточной среде.

++14. Какими способами можно создать и запустить поток?
    /14/
    1 - Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable.
    Этот интерфейс содержит метод run(), который будет выполняться в новом потоке.
    Поток закончит выполнение, когда завершится его метод run().
       #
        Something implements Runnable
        Something myth = new Something();
        Thread myThready = new Thread(myth);
        myThready.start();

    2 -  Создать потомка класса Thread и переопределить его метод run().
    Потом вызвать потомок.start().

    ___**ПРО ДЕМОНЫ**__
    В Java процесс завершается тогда, когда завершается последний его поток.
    Даже если метод main() уже завершился, но еще выполняются порожденные им потоки,
      система будет ждать их завершения.
    Однако это правило не относится к особому виду потоков – демонам.
    Если завершился последний обычный поток процесса, и остались только потоки-демоны,
      то они будут принудительно завершены и выполнение процесса закончится.
    Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод setDaemon(true);
    Проверить, является ли поток демоном, можно вызвав его метод boolean isDaemon();

++15. Суть интерфейса Callable.
    /15
    Интерфейс Callable является параметризованным типом,
      с единственным общедоступным методом call().
    Метод call имеет дополнительную возможность возвращать результат,
      а также разрешено выдавать проверенные исключения.
    Результат, полученный в результате задания задачи Callable ,
        доступен для использования через будущее Future.
    Future можно рассматривать как контейнер, который содержит результат вычисления Callable
        public interface Callable<V>{
            V call() throws Exception;
        }
        interface Future<V> {
            V get();
            V get(long timeout, TimeUnit unit);
            boolean cancel(boolean mayInterruptIfRunning);
            boolean isCancelled();
            boolean isDone();
        }
         ExecutorService es = Executors.newSingleThreadExecutor();
         Future<String> result = es.submit(new ComplexCalculator());
                                //ComplexCalculator implements Callable and return String!
         System.out.println("Result of Complex Calculation is : " + result.get());

    Вычисление вызываемого может продолжаться в другом потоке,
      и любая попытка использовать результат Future будет блокировать
      и будет возвращать результат только после его появления.

    Коротко:
    - Callable должен реализовать метод call(), а Runnable должен реализовать метод run().
    - Callable может вернуть значение, но Runnable не может.
    - Callable может выставить проверенное исключение, но Runnable не может.

++16. Как остановить поток?
    /16/
    16.1 Все потоки нужно прерывать при помощи метода interrupt().
    В самом потоке, который возможно будет прерван -
      нужно устанавливать проверки isInterrupted() во всех ключевых точках (где это необходимо)
      и обрабатывать соответственно.
    16.2 Класс Thread содержит в себе скрытое булево поле, которое называется флагом прерывания.
    Установить этот флаг можно вызвав метод interrupt() потока.
    Проверить же, установлен ли этот флаг, можно двумя способами.
        Первый способ — вызвать метод bool isInterrupted() объекта потока,
        второй — вызвать статический метод bool Thread.interrupted().

    Путь 1. Мы из main выставляем флаг interrupt для потока A.
    Внутри себя поток А проверяет прерван ли он, если да то он завершает свою работу -≥ return!
    Путь 2. Поток внутри себя ловит InterruptedException,
      если исключение было сгенерировано поток заканчивает работу -≥ return!!
      ** По соглашению любой метод, который прерывает свою выполнение бросая исключение InterruptedException,
      очищает флаг статуса прерывания, когда он бросает это исключение.

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            Занимательно то, что флаг isInterrupted() не заставляет поток остановиться и "умереть".
            Поток может ничего не делать, но продолжать жить дальше!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # В Java (существовали) средства для принудительного завершения потока.
    В частности метод Thread.stop() завершает поток незамедлительно после своего выполнения.
    Однако этот метод, а также Thread.suspend(), приостанавливающий поток, и Thread.resume(),
      продолжающий выполнение потока, были объявлены устаревшими
      и их использование отныне крайне нежелательно.
    Дело в том что поток может быть «убит» во время выполнения операции,
      обрыв которой на полуслове оставит некоторый объект в неправильном состоянии,
      что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке.

++17. Проблемы многопоточности. http://java-course.ru/begin/multithread_02/
    /17/ 111
    Потоки общаются в основном разделяя свои поля и поля объектов между собой.
    Эта форма общения очень эффективна, но делает возможным два типа ошибок:
     1 - вмешательство в поток (thread interference)
     2 - ошибки консистентности памяти (memory consistency errors).
    Для того чтобы предотвратить эти ошибки, нужно использовать синхронизацию потоков.
    Однако синхронизация может привести к
     3 - конкуренции потоков (thread contention), которая возникает,
        когда два или более потока пытаются получить доступ к одному и тому же ресурсу одновременно,
        что приводит к тому, что среда выполнения Java выполняет один или более этих потоков
        более медленно или даже приостанавливает их выполнение.
     3.1 - Голодание (starvation) и 3.2 - активная блокировка (livelock) — это формы конкуренции потоков.

     1 - Вмешательство в поток происходит, когда два действия выполняются разными потоками,
        но используют одни и те же данные.
     2 - Ошибки консистентности памяти (memory consistency errors) возникают,
        когда разные потоки имеют несовместимое представление о том, что должно быть общими данными.
        !! -> Ключ к исключению ошибок консистентности памяти — это понимание связи происходит-до (happens-before).
        Эта связь гарантирует, что данные, записанные в память одной инструкцией, видимы в другой.

        Есть разные способы создания связи происходит-до (happens-before).
        Один из них — это синхронизация.

        Язык программирования Java предоставляет два базовых способа синхронизации:
            11 - синхронизированные методы (synchronized methods)
            22 - синхронизированные инструкции (synchronized statements).
            **НО есть и другие, более сложные, способы синхронизации.
        11 - Чтобы сделать метод синхронизированным, нужно добавить ключевое слово synchronized к его объявлению.
            **Конструкторы не могут быть синхронизированными.
        22 - Каждый объект имеет внутреннюю блокировку (монитор), который с ним связан.
             Поток владеет блокировкой объекта между временем получения и временем освобождения блокировки.
             **Возможность потоков получать одну и ту же блокировку несколько раз
              называется повторная синхронизация (reentrant synchronization).

     Атомарное действие — это действие которое происходит полностью и сразу.
      - Чтения и запись атомарны для ссылочных переменных и примитивных типов(кроме long  и double ) -> потому,
            что они больше 32 бит.
      - Чтение и запись атомарны для всех переменных, объявленных как volatile  (включая long  и double ).

     --Взаимная блокировка (deadlock)-- описывает ситуацию,
      когда два или более потока блокируются навсегда, каждый ожидая другого.

     --Голодание (starvation)-- описывает ситуацию,когда поток не может получить доступ к
      совместно используемым ресурсам и не может продвинуться в своём выполнении дальше.

     --Активная блокировка (livelock)--
      Как и взаимная блокировка (deadlock), активно заблокированные потоки не могут продвинуться дальше.
      Однако эти потоки не заблокированы — они просто слишком заняты, отвечая друг другу,
       чтобы вернуться к работе.

     --Guarded blocks--
      Наиболее часто используемый способ согласования — защищённые блокировки (guarded blocks).
      Такой блок начинается с выбора условия, которое должно быть true,
        перед тем как может осуществиться блокировка.
      **Наиболее эффективно использовать Object.wait(), чтобы приостановить работу текущего потока,
        если какое-то условие еще не наступило.
            ####Мы ждем чтобы joy стало true и мы прошли цикл while и выполнили то что хотим!!
            while(!joy) {
                    try {
                        wait();
                    } catch (InterruptedException e) {}
            }
            ...код который должен работать
            ####
      **Чтобы выпустить поток из этого состояния нужно вызвать notifyAll(); -> не понял!! ???

      --Неизменяемые объекты (immutable objects)--
      Неизменяемые объекты особенно полезны в многопоточных приложениях.
      Так как они не могут менять своего внутреннего состояния,
       то они не могут быть испорчены вмешательством в поток (thread interference)
       или прочитаны в некорректном состоянии.
      Чтобы класс был immutable:
          a. Не создавайте setter-ов.
          б. Делайте все поля final и private.

      --Объекты Lock--
      Высокоуровневое API java.util.concurrent.locks.
      Преимущество их над внутренними блок-ми в том,
       что они могут отказаться от участия в попытке приобрести блокировку.

      **Атомарные переменные
      Пакет java.util.concurrent.atomic содержит классы,
        которые поддерживают атомарные операции над простыми переменными.
      !#! Замена int на AtomicInteger
        позволит защититься от вмешательства в поток (thread interference) без synchronized.

***************************

    /17/ 2222
        1. Проблема первая — доступ к одному ресурсу из нескольких потоков.
            Можно сделать все очень надежно, но тогда производительность упадет.
            1.1 Монитор. Есть в каждом обьекте.
                Пишем synchronized и поток должен завватить монитор нашего объекта,
                    остальные встают в очередь на монитор.
                !!! Если у объекта три метода с synchronized,
                    то эти методы могут быть выполнены разными потоками ПОСЛЕДОВАТЕЛЬНО
                    т.к. хватается при выполнении методе весь Объект!
                Но можно use (this).synchronized уже внутри метода.
                !!!! Если поле static, то Объект это класс, в котором больше методов synchronized,
                     чем просто у одного объекта этого класса!
            1.2 AtomicInteger, AtomicBoolean - потокобезопасные переменные!

        2 Проблема вторая — синхронизация взаимодействия.

++18. Какие приходилось решать задачи с многопоточностью?
    /18/
    - Сортировка массива произвольным числом потоков. AtomicInteger and CountDownLatch use there.
    - Эмуляция лифта!

++19. Для чего служит модификатор volatile?
    /19/
    Ключевое слово volatile необходимо использовать для переменных, которые используются разными потоками.
    Это связано с тем, что значение переменной, объявленной без volatile,
      может кэшироваться отдельно для каждого потока,
      и значение из этого кэша может различаться для каждого из них.
    Объявление переменной с ключевым словом volatile отключает для неё такое кэширование
      и все запросы к переменной будут направляться непосредственно в память.

    !!**There is bad situation with multiprocessor.

++20. Написать реализацию синглтона с синхронизированной инициализацией.
    /20/
    20.1
    public class Singleton {
    	private static Singleton instance;
        !!!!!!!!
        private Singleton(){}

    	public ! static ! synchronized Singleton getInstance() {
    		if (instance == null) {
    			instance = new Singleton();
    		}
    		return instance;
    	}
    }
    Синхронизация полезна только один раз, при первом обращении к getInstance(),
     после этого каждый раз, при обращении этому методу, синхронизация просто забирает время.
    ** use: Singleton my = Singleton.getInstance();!!!!

    20.2
    public enum Singleton {
    	INSTANCE;
    }
    20.3
    public class Singleton {
    	public static final Singleton INSTANCE = new Singleton();
    }
    *Потеряем ленивую инициализация(Объект instance будет создан classloader-ом во время инициализации класса)

    20.4
     public class Singleton {
        	private static !volatile! Singleton instance;
            private Singleton(){}

        	public static Singleton getInstance() {
        	    if (instance == null) {
        	        synchronized (Singleton.class){
        		        if (instance == null)
        			        instance = new Singleton();
        		    }
        		return instance;
        		}
        	}
        }
    ***___Отнестись скептически___*** :
    Не смотря на то, что этот вариант выглядит как идеальное решение,
    использовать его не рекомендуется т.к. товарищ Allen Holub заметил,что использование
    volatile модификатора может привести к проблемам производительности на мультипроцессорных системах.

++21. Как создать servlet?
    /21/
    21.1<dependency>
           <groupId>javax.servlet</groupId>
           <artifactId>javax.servlet-api</artifactId>
           <version>3.1.0</version>
        </dependency>

    22.2
    Создаем класс MainServlet.java и наследуем его от HttpServlet и
      переопределяем два метода void doGet(…) и void doPost(…).
    **Известно, что HTTP протокол имеет 7 методов передачи данных:
      — DELETE — HEAD — GET — OPTIONS — POST — PUT — TRACE

    22.3.1
    Теперь создаем папку src/main/webapp/WEB-INF,
      а там создаем файл web.xml в этом файле мы зарегистрируем наш сервлет и замапим его на URL.

    22.3.2
    @WebServlet("/")
    Данная аннотация регистрирует сервлет в контексте приложения,
      это тоже самое что мы делали в web.xml.

++22. Есть две таблицы. Написать для Hibernate класс, на который будут мапиться данные из
        таблицы book
       table author (id, fio) ; table book(id, title, author_id)
    /22/
    Существующие аннотоции:

    @Entity @Table(имя таблицы)  @Id
    @Column(name="имя столбца")
    @ManyToMany @OneToMany @ManyToOne
    @JoinColumn
    @Temporal

    *Для реализации отношения ManyToMany добавим таблицу author_book!

    @Entity
    @Table(name="book")
    public class Book {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private long id;

        @Column(name="title",unique = true, nullable = false, length = 100)
        private String title;

        @ManyToMany
        @JoinTable(name = "author_book",
        joinColumns = @JoinColumn(name = "book_id"),
        inverseJoinColumns = @JoinColumn(name = "author_id"))
        private Set<Author> authors;

    }

    @Entity
    @Table(name="author")
    public class Author {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private long id;

        @Column(name="fio")
        private String FIO;

        @ManyToMany
        @JoinTable(name = "author_book",
        joinColumns = @JoinColumn(name = "author_id"),
        inverseJoinColumns = @JoinColumn(name = "book_id"))
        private Set<Book> bookList;
    }

!!!!!!!!!!!!!!!!!
   -JavaBeans — классы в языке Java, написанные по определённым правилам.
   -xml — маппинг является единственным способом связать
        JavaBean с hibernato'm если нету возможности редактировать этот самый бин.
!!!!!!!!!!!!!!!!

++23. Как в спринге создать свой контроллер?
    /23/
    Аннотация @Controller указывает, что конкретный класс является контроллером.
    Аннотация @RequestMapping используется для мапинга (связывания) с URL.
    #
    @Controller
    @RequestMapping("/hello")
    public class HelloController {
         @RequestMapping(method = RequestMethod.GET)
         public String printHello(){ ...; }
    }

++24.1 Суть MVC.
    /24/
    Паттерн Model — View — Controller (Модель — Вид — Контроллер) при помощи слабо связанных
     готовых компонентов.
    Паттерн MVC разделяет аспекты приложения (логику ввода, бизнес-логику и логику UI),
     обеспечивая при этом свободную связь между ними.
    - Model инкапсулирует (объединяет) данные приложения, в целом они будут состоять из бинов.
    - View отвечает за отображение данных Модели — генерируя HTML, которые мы видим в своём браузере.
    - Controller обрабатывает запрос пользователя, создаёт соответствующую Модель и передаёт её для отображения в Вид.

    24.2 Spring MVC - построен вокруг DispatcherServlet.
       # Цифры это последовательность действий!
                http request     http response
                        0 |       | 5
               ______   DispatcherServlet            ____
            1 |          2 |         3 |               4 |
    Handler Mapping     Controller-1   View Resolver    View
     ( определяет           ...
      Controller )        Controller-n

!!!!!!!!!!
    HandlerMapping, Controller и ViewResolver - части интерфейса
            WebApplicationContext extends ApplicationContext, с некоторыми дополнительными особенностями,
            необходимыми для создания web-приложений.
!!!!!!!!!!!

++25. С какими модулями спринга работал?
    /25/
    spring-beans
    spring-core
    spring-context(Context) для поддержки класса ApplicationContext - загрузка ресурсов, инициализация контекста.

    Существует еще:
        Spring Expression Language
        Spring JDBC
        Spring ORM
        Spring Data
        Spring AOP
        Spring Security
        Spring Boot - огонь! # Spring Boot DevTools и т.д.

++26. С какой версией спринга работал?
    /26/
            --> версия 2.5 <-- !

++27. Что такое Bean? Чем отличается от других объектов?
    /27/
    Bean -  управляемый IoC контейнером компонент.
    То есть бин создается и инициализируется IoC контейнером и существует внутри него.


++27а.Что такое IoC контейнер?
    /27a/
    это объект, который обеспечивает жизненый цикл bean'a!

    Container, на основе metadata (файл xml), создаёт объекты, связывает их вместе,
        настраивает и управляет ими от создания до момента уничтожения.
    Для управления компонентами (Spring Beans), из которых состоит приложение,
        Spring Container использует Внедрение Зависимостей (DI).
    #В Spring имеется 2 различных вида контейнеров:
        1. Spring BeanFactory Container;
        2. Spring ApplicationContext Container - более продвинут, но тежелее по ресурсам!!! Его виды:

            – FileSystemXmlApplicationContext
            Загружает данные о бине из XML файла.
            При использовании этой реализации в конструкторе необходимо указать полный адрес конфигурационного файла.

            – ClassPathXmlApplicationContext
            Этот контейнер также получает данные о бине из XML файла.
            Но в отличие от FileSystemApplicationContext,
                в этом случае необходимо указать относительный адрес конфигурационного файла (CLASSPATH).
            #ApplicationContext context = new ClassPathXmlApplicationContext("myInit.xml");

            – WebXmlApplicationContext
            Эта реализация ApplicationContext получает необходимую информацию из веб-приложения.


++28. Какими способами можно объявить Bean в спринге?
    /28/
        – XML
        – Аннотации Java
        – Java код
!!!!
    Взаимосвязь между _IoC & DI_ такая же как _Agile & Scrum_
!!!!
++29. В чём суть IoC - Inversion of control(инверсия управления)?
    /29/
    1. Это некий абстрактный принцип, набор рекомендаций для написания !! --> слабо связанного кода <-- !!
        Суть которого в том, что каждый !! компонент !! системы должен быть как можно !! -> более изолированным <- !! от других,
        не полагаясь в своей работе на детали конкретной реализации других компонентов.
    2. Согласно подходу IoC инверсии управления
        если у нас есть клиент, который использует некий сервис, то он должен делать это не напрямую, а через посредника, своего рода аутсорсинг.
          ##
           CLIENT      SERVICE
              |          ^
              |          |
               -> AGENT -

    3. IoC - не я вызываю функцию, а framework вызывает мой класс! # IoC контейнер сервлетов вызывает мой сервлет!

++30. В чём суть DI - dependency injection (внедрение зависимостей)?
    /30/
    1. DI - это одна из реализаций принципа IoC (помимо этого есть еще Factory Method, Service Locator).
        Суть в том, что контейнер создает bean на основе данных из xml файла!
    2. DI - обьект моего класса встраивается/внедряется туда куда надо =)! мой бин встраивается в мой сервлет!

++31. Как реализуется DI(внедрение зависимостей)?
    /31/
    Есть три варианта:
        - Constructor Injection - наиболее надежный
        - Setter Injection -
        - Method Injection -
    Но все они основаны на одном принципе. Есть контейнер который на основе metadata (xml файл) создает бин, и вставляет его в нужное место - это и есть DI!
       Либо есть аннотация @autowired, либо мы получаем объект из самого контеста (выше есть пример)!

!!!!!!!!!!!!!!!!!!!!!!!!
    **___Пример___**
    Внедрение зависимостей позволяет нам связывать классы друг с другом, при этом сохраняя их независимыми друг от друга.
    Есть класс Exam внутри его есть сеттер для инициализации ссылки на другой класс Answer.
    Мы создает файл myInit.xml в нем создаем bean exam и в этом exam через property инициализируем другой bean Answer.
    Потом в main создаем
        # ApplicationContext context = new ClassPathXmlApplicationContext("myInit.xml"); - ЭТО IoC Container!!!!
    Передаем наш xml в ApplicationContext  и вызываем
        # Exam ex = context.getBean("exam");
        # ex.examCheck() - в этом методе мы use Answer;
!!!!!!!!!!!!!!!!!!!!!!!!

++32. Есть два бина от одного интерфейса. Как конкретизировать, какой бин нужно инжектить?
    /32/
    Для установки конкретного экземпляра необходимо использовать аннотацию @Qualifier.
    #Qualifier(id_bean) или дефолтовое имя bean'a;

++33. Что такое DispatcherServlet в спринге?
    /33/
    Вся логика работы Spring MVC построена вокруг DispatcherServlet,
     который принимает и обрабатывает все HTTP-запросы (из UI) и ответы на них.
                     http request     http response
                             0 |       | 5
                    _________DispatcherServlet________________
                 1 |          2 |         3 |               4 |
         Handler Mapping     Controller-1   View Resolver    View
          ( определяет           ...
           Controller )        Controller-n

    -После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping,
      который определяет, какой Контроллер должен быть вызван, после чего,
      отправляет запрос в нужный Контроллер.
    -Контроллер принимает запрос и вызывает соответствующий служебный метод, основанный на GET или POST.
     Вызванный метод определяет данные Модели, основанные на определённой бизнес-логике и
      возвращает в DispatcherServlet имя Вида (View).
    -При помощи интерфейса ViewResolver DispatcherServlet определяет,
      какой Вид нужно использовать на основании полученного имени.
    -После того, как Вид (View) создан, DispatcherServlet отправляет данные Модели в виде атрибутов в Вид,
      который в конечном итоге отображается в браузере.
    ***
    Все вышеупомянутые компоненты, а именно, HandlerMapping, Controller и ViewResolver,
     являются частями интерфейса WebApplicationContext extends ApplicationContext,
     с некоторыми дополнительными особенностями, необходимыми для создания web-приложений.


++34.1. Что такое servlet?
    /34/
    Сервлет является интерфейсом Java javax.servlet.Servlet,
        реализация которого расширяет функциональные возможности сервера.
    Сервлет взаимодействует с клиентами посредством принципа запрос-ответ.

    Это класс, расширяющий интерфейс HttpServlet, у которого есть два главных метода
      void doGet(HttpServletRequest request, HttpServletResponse response){}
      void doPost(HttpServletRequest request, HttpServletResponse response){}

    ***
    Для запуска сервлетов используется Web-сервер с контейнером сервлетов.
    ***
++34.2 Контейнер сервлетов
    /34.2/
    Программа, представляющая собой сервер,
        который занимается системной поддержкой сервлетов и
        обеспечивает их жизненный цикл.
    Может работать как полноценный самостоятельный веб-сервер,
        быть поставщиком страниц для другого веб-сервера.
    Обеспечивает обмен данными между сервлетом и клиентами,
        берёт на себя выполнение таких функций, как
            -создание программной среды для функционирующего сервлета,
            -идентификацию и авторизацию клиентов,
            -организацию сессии для каждого из них.

++35. С какими технологиями хотелось бы работать, что-то новое изучить?
    /35/
    Может быть Kotlin!

    ???????
    На самом деле не знаю!!

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++_Мои_вопросы_+++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

++1. Размер объекта?
    /1/
    Зависит от
        - версии java
        - Издателя
        - Разрядность ОС
        - Параметров запуска JVM

    Header - 8 байт *у массисва 12
        - MarkWord (hash, age) ?????__Max hash много меньше 2^31__?????
        - Klass pointer
        - *size
    Примитивные типы
    Ссылки на другое объекты
    Гранулярность


++2. GC его работа, какие GC знаешь?
    /2/
    Есть понятие достижимого и не достижимого объекта!
    Reference, static переменные, классы и потоки - это root nodes(rn).
    Rn расположены в стеке. Они указавают на обьекты, которые расположены в heap.
    Если обьект в heap есть, то это достижиный rn.

    Есть young и old(tenured) области.
    Young делиться на eden(все объекты появляются здесь), survivor0 и survivor1.
    Работа GC в этой области называется - Minor GC. Major GC - это работа в области old.
    При Minor GC анализируется eden область и достижимые объекты, перемещаются в survivor0.
    При этом считает что eden свободен и его можно снова заполнять.
    Долгоживущие объекты перемещаюся в survivor1.Объект переживший 8(храниться в header об.) Minor GC,
     перемещается в tenured область.

    Young GC:             Old GC: #имеют разные алгоритмы работ
        - Copy          - MarkSweepCompact - самый простой однопоточный
        - PS Scavenge   - PS MarkSweep  - use мало ресурсов, но пауза Stop-the-word(STW) будет большим!
        - PerNew        - ConcurrentMarkSweep - use много ресурсов, но старается свести к min паузу STW.
    ** G1 не имеет разделения на Young GC, Old GC у него особый алгоритм. Он нарезает память на куски.
       У него может быть 4(и болле) области под eden, survivor и tenured.

++3. Раскажи про настройку памяти для приложения?
    /3/
    Должно быть Xms=Xmx (минимальный = максимальный размер памяти)
    MetaSpace тоже можно ограничивать. Тут храниться метаинформация!

??4. Магия kill -3 %p
    /4/
    Полезно иметь возможность при каком-то событии(#OutOfMemoryError) сделать так что бы при
        возникновении этого собятия приложение писало в лог свое текущее состояние.
    Для этого нужно при старте приложения написать -XX:(необходимое событие)(#onOutOfMemoryError)="kill -3 %p"

    *Thread dump

     dump всех потоков в stdout:
     windows: CTRL-Break в консоле, где запущено приложение
     unix: kill -3 PID


++5. JavaManagementExtended(JMX) и ManagementBean(MBean)
    /5/
    Объект в программе нужно обернуть в MBean, и при помощи jconsole и JMX
      в runtime смотреть состояние приложения.

++6.Какие classLoader ты знаешь?
    /6/
    Их 3
    1. BootStrap
    2. Extension
    3. Class path

7.  Зачем они нужны?

++8. Что такое контейнер сервлетов?
    /8/
    Контейнер сервлетов  — программа, представляющая собой сервер, который занимается системной поддержкой
     сервлетов и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях.
    Может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера,
      например Apache, или интегрироваться в Java EE сервер приложений.
    Так же он обеспечивает обмен данными между сервлетом и клиентами,
     берёт на себя выполнение таких функций, как создание программной среды для функционирующего сервлета,
     идентификацию и авторизацию клиентов, организацию сессии для каждого из них.

9. Основные элементы Spring?
    /9/
        - ApplicationContext

++10. Что может победить finally?
    /10/
    *finally может “съесть” любой эксепшн
          public static int f() {
                try {
                    throw new RuntimeException();
                } finally {
                    return 0;
                }
          }
    внернет 0!

    Победить finally может только System.exit(..).

    Это для Петра!
    !!!!Написать тест!

++11.1 Опиши Http протокол- HyperText Transfer Protocol.
    /11.1/

    В основе протокола HTTP лежит концепция клиент-серверной архитектуры:
        клиент, чаще всего браузер, делает запрос на сервер.
    Существует множество видов запросов, самые распространённые — это
    GET (означает, что клиент хочет получить данные) - прочитать сообщение в vk.
    POST(означает, клиент хочет послать данные на сервер) - написать сообщение другу в vk.

    Всего HTTP протокол имеет 7 методов передачи данных:
    — DELETE — HEAD — GET — OPTIONS — POST — PUT — TRACE.

    Существует HTTP - 1.0 и 1.1.
    # Запрос
    GET /im HTTP/1.1
    Host: vk.com
    User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9b5) Gecko/2008050509 Firefox/3.0b5
    Accept: text/html
    Connection: close

        !* /im = URL включает в себя путь до ресурса и параметры, которые передаются после пути.
        !* HTTP-headers(что-то:что-то).

    #Ответ
    HTTP/1.1 200 OK
    Date: Wed, 27 Aug 2017 09:50:20 GMT
    Server: Apache
    X-Powered-By: PHP/5.2.4-2ubuntu5wm1
    Content-Language: ru
    Content-Type: text/html; charset=utf-8 //кодировка
    Content-Length: 18 //длина данных в байтах
    Connection: close

    Го гулять

    Итог:
    !* HTTP-протокол работает как функция запрос-ответ в клиентско-серверной модели вычислений.
       Отсюда минус в том, что НЕЛЬЗЯ что-то передать без запроса!
    !* Есть возможность использования заголовка Upgrade для переключения на обмен данными по другому протоколу.
        Такая возможность используется, в частности, для организации обмена данными по !*_ протоколу WebSocket _*!,
            позволяющий обеим сторонам передавать данные в нужный момент, без отправки дополнительных HTTP-запросов)
    !* Говорят "HTTP работает поверх TCP".
    !* HTTPS (HyperText Transfer Protocol Secure) - для более безопасной передачи данных!
    !* Протокол 7 го уровня.
    !* Соединение типа "Клиент-сервер".
    !* HTTP use как протокол передачи информации для других протоколов прикладного уровня, #SOAP и др.
        Тогда говорят, что протокол HTTP используется как «транспорт».

++11.2  Модель OSI:
    /11.2/
                  =  7 Физический уровень      = прикладная задача                        = HTTP, SMTP
          Поток   =  6 Канальный уровень       = представление данных шифрование
     OC           =  5 Сетевой уровень         = взаимодействие хостов
         Сегмент  =  4 Транспортный уровень    = соединени, контороль передачи данных     = TCP, UDP
    =================================
          пакет   =  3 Сеансовый уровень       = логическая адресация маршрутизация       = IP,
    Сеть  фрейм   =  2 Уровень представления   = физичекая адресация
           бит    =  1 Прикладной уровень      = физический канал


12. TCP/IP против udp
    /12/
    TCP - пытаясь связаться с другим компьютером в сети
      (а точнее с приложением находящимся на другом компьютере) TCP сначала убедится,
      что приложение отвечает и после этого сообщит, что соединение установлено и можно посылать пакеты.


13.  Web-сервер
    /13/
    Является специальной программой, которая запускается на компьютере и занимает определенный порт.
    Web-сервер, который умеет работать с сервлетами, запускает Java-машину, которая в свою очередь выполняет сервлет,
      а сервлет отдает данные, которые он сформирует.
    Т.е. при приходе запроса от клиента сервер с помощью специального конфигурационного файла может определить,
     какой сервлет выполнить, сервлет выполняется и создает HTML-страницу, которую сервер отправляет клиенту.

14. SOAP(работа с веб-сервисами)


15. WSDL
    /15/
    (англ. Web Services Description Language) — язык описания веб-сервисов и доступа к ним,
      основанный на языке XML.

16. JAX-WS
    /16/
      Java API for XML Based Web Services (JAX-WS) — это прикладной программный интерфейс языка Java
        для создания веб-служб, являющийся частью платформы Java EE.
      JAX-WS является заменой технологии JAX-RPC, предоставляя более документо-ориентированную
       модель сообщений и упрощая разработку[1] веб-служб за счёт использования аннотаций,
       впервые появившихся в Java SE 5.
      Технология JAX-WS является стандартом и описана в JSR 224.

17. *** Совет! ***
      Перед собеседованием проиграйте в памяти все проекты, в которых вам приходилось участвовать.
      Вас по-любому об этом спросят, поэтому подготовьтесь к данной части заранее.


18. XPath
    /18/
    XPath предоставляет специальный синтаксис для поиска и выборки данных в XML документе.
    Используя XPath выражения, мы можем произвести выборку по условию,
      найти узлы или точное значение из любой части XML-документа.
    XPath является частью платформы Java SE и находится в пакете javax.xml.xpath.
    Написал простой пример работы с xpath и xml.

19. Потокобезопасные коллекции. пакет java.util.concurrent.
    /19/
    - CopyOnWriteArrayList - определяется в Javadoc как "потокобезопасный вариант коллекции ArrayList,
     в которой все изменяющие операции (add, set и т.д.) реализованы посредством создания свежей копии массива".
    Перед каждой модификацией коллекция копирует свое содержимое в новый массив,
     чтобы операции !! чтения содержимого массива выполнялись без синхронизации !!(отсутствие сихронизации ускоряет жизнь =) )
     (так как они никогда не работают с изменяемыми данными).
    Таким образом, коллекция CopyOnWriteArrayList идеальна именно для того сценария,
     в котором ArrayList нас подводит: коллекции с частым чтением и редкой записью,
     например слушатели (Listener) для события JavaBean.

     - BlockingQueue(Интерфейс) - является очередью (Queue), т.е. его элементы хранятся в порядке
      «первый пришел, первый вышел» (FIFO – first in, first out).
     Элементы, вставленные в коллекцию в определенном порядке, будут извлечены из нее в том же самом порядке.
     Также интерфейс гарантирует, что любая попытка извлечь элемент из пустой очереди заблокирует
       вызывающий поток до тех пор, пока в коллекции не появится элемент, который можно извлечь.
     Аналогично, любая попытка вставить элемент в заполненную очередь заблокирует вызывающий поток,
       пока в коллекции не освободится место для нового элемента.
     !! BlockingQueue изящно решает проблему передачи элементов, собранных одним потоком,
       для обработки в другой поток без явных хлопот о проблемах синхронизации.

20. пакет java.util.concurrent.
    /20/
    1.Concurrent Collections
        -CopyOnWrite коллекции
            -CopyOnWriteArrayList<E>
            -CopyOnWriteArraySet<E>
        -Scalable Maps
            -ConcurrentMap<K, V>
            -ConcurrentHashMap<K, V>
            -ConcurrentNavigableMap<K,V>
            -ConcurrentSkipListMap<K, V>
            -ConcurrentSkipListSet<E>
    2.Queues
        -Non-Blocking Queues
            -ConcurrentLinkedQueue<E>
            -ConcurrentLinkedDeque<E>
        -Blocking Queues
            -BlockingQueue<E>
            -ArrayBlockingQueue<E>
            -DelayQueue<E extends Delayed>
    3.Synchronize
        -Semaphore
        -CountDownLatch
        -CyclicBarrier
        -Exchanger<V>
        -Phaser
    4.Executor

    5.Locks
        -Condition
        -Lock
        -ReentrantLock
        -ReadWriteLock
    6.Atomics
        -AtomicBoolean, AtomicInteger, AtomicLong, AtomicIntegerArray, AtomicLongArray
            **За счет использования CAS,
              операции с этими классами работают быстрее, чем если синхронизироваться через synchronized/volatile.
            **In computer science, compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization.

21. Раскажи в чем суть wait(), notify(), notifyAll()?
    Берется некий объект.
    Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор.
    На этом его работа приостанавливается. И при вызове wait() монитор !!! ОТПУСКАЕТСЯ!!
    Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор объекта),
        в результате чего, ждущий на объекте поток "просыпается" и продолжает свое выполнение.
    Подчеркиваю, в обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, ибо методы семейства wait/notify не синхронизированы!

    # Object sync = new Object();

    Thread 1
    ....
       synchronized(sync){
            sync.wait(); // Будет ждать пока не вызовется notify()!
                         // Eсли поток останавливается внутри метода wait, то монитор для sync отпускается!
       }

    Thread 2
    ....
        synchronized(sync){
           sync.notify();
        }
!!!!!!!!
        Вызов wait происходит в синхронизированном блоке.
        Следовательно, прямо после вызова монитор должен быть захвачен, ибо выйти из блока мы еще не успели.
        Внутри же метода wait монитор отпускается и захватывается потоком, вызывающим notify.
        Внимание, вопрос: в какой момент происходит обратный захват монитора потоком, ждущим в wait?

        Ответ: Когда поток 2, сделав notify(), выходит из блока synchronized, поток 1, после wait(), снова!! захватывает монитор!




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++_От_ПЕТРА_+++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1.1 Какие анотации Spring знаешь?
    @Bean - Аннотация @Bean используется для указания того,
        что метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером.
    @Bean - для того, чтобы объявить Bean-объект(далее просто бин), достаточно указать аннотацию @Bean тому методу,
        который возвращает тип бина как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component
    @Bean (# @Bean(initMethod = "initMethod", destroyMethod = "destroyMethod") )
??  @Component - наследники @Repository, @Service и @Controller - Все они являются общими шаблонами для любых компонентов,
        управляемыми контейнеером.
    @ComponentScan - По умолчанию, такая конфигурация сканирует на наличие классов с аннотацией @Component
        и его потомков в том пакете, в котором сама находится, а также в подпакетах.
        Но так @ComponentScan(basePackages = "lessons.services") мы указали конкретный пакет!
    @Required - применяется к setter-методу бина и указывает на то,
        чтобы соответствующее свойство метода было установлено на момент конфигурирования значением из определения бина или автоматического связывания.
         #public class GreetingServiceImpl implements GreetingService {

              private ApplicationContext context;

              @Required
              public void setContext(ApplicationContext context) {
                  this.context = context;
              }
          }
    @Description - позволяет предоставить более подробное описание бина, например, в целях мониторинга.
    @Configuration - Класс с аннотацией @Configuration говорит о том, что он является источником определения бинов.
    @PostConstruct и @PreDestroy для жизненого цикла bean'a!
    @Scope("область_видимости") - "область_видимости" =)!
    @Autowired - автоматическое связывание.
    @Qualifie - конкретизирует бин в процессе связывания.

    # Пример автоматического связывания:
    1.1 context:annotation-config(in xml file) - добавляет все bean'ы пост процессора в конфигурации.
    1.2 context:component-scan(in xml file) - сканируем на наличие @Component или @Service.
    2. @Autowired - заместо строки в xml.
    3. @Qualifier("имя bean") - для оточнения бина при наличии двух бинов одного интерфейса.
    4. @Component - нужно разместить над классом где будет жить созданный бин.

     #
     @Component
     public class Print {
        @Autowired
        @Qualifier("circle")
        private Figure fig;
     }

     5. Можно обойтись без xml файла,
        а использовать AnnotationConfigApplicationContext - создается в main.
     Он ищет и создает бины!
     6. В этом случаи для классы Circle и Rectangle нужно пометить как @Component.
        А над конструктором поставить @Autowired.
!!!!!!!!!!!!!!
    Прописать значения для коснтруктора можно через @Value и без xml файла,
        но при изменении значений нужно перекомпилировать проект - ЭТО ПЛОХО!
    Поэтому параметры конструкторов оставляют в xml файле и тогда при изменении значений
        перекомпилировать не придеться - "они применяться сразу"!!!
!!!!!!!!!!!!!


!!!!
    Т.к. кандидатов для автоматического связывания может быть несколько,
        то для установки конкретного экземпляра необходимо использовать аннотацию @Qualifier.
!!!!!

!!!!!!!!!!
    **__Полный @Configuration vs легкий @Bean режимы__**
    Когда методы с аннотацией @Bean определены в классах, не имеющих аннотацию @Configuration,
        то относятся к обработке в легком режиме, то же относится и к классам с аннотацией @Component.
    Иначе, такие методы относятся к полному режиму обработки.
    В отличие от полного, в легком режиме @Bean методы не могут просто так объявлять внутренние зависимости.
    Поэтому, в основном предпочтительно работать в полном режиме, во избежание трудноуловимых ошибок.
!!!!!!!!!!

1.2  Инициализация IoC контейнера
    Для того, чтобы приступить к настройке и изучению Spring IoC контейнера,
        вы должны инициализировать ApplicationContext, который поможет также с разрешением зависимостей.
    Для обычной Java-конфигурации применяется AnnotationConfigApplicationContext,
        в качестве аргумента к которому передается класс, либо список классов с аннотацией @Configuration,
         либо с любой другой аннотацией JSR-330, в том числе и @Component.

++1.3 Области видимости(scopes) бинов
     Cписок областей видимостей:
    - singleton - По умолчанию. Spring IoC контейнер создает единственный экземпляр бина.
        Как правило, используется для бинов без сохранения состояния(stateless)
    - prototype - Spring IoC контейнер создает любое количество экземпляров бина.
        Новый экземпляр бина создается каждый раз, когда бин необходим в качестве зависимости, либо через вызов getBean(). Как правило, используется для бинов с сохранением состояния(stateful)
    - request - Жизненный цикл экземпляра ограничен единственным HTTP запросом;
        для каждого нового HTTP запроса создается новый экземпляр бина.
        Действует, только если вы используете web-aware ApplicationContext
    - session - Жизненный цикл экземпляра ограничен в пределах одной и той же HTTP Session.
        Действует, только если вы используете web-aware ApplicationContext
    - global session - Жизненный цикл экземпляра ограничен в пределах глобальной HTTP Session(обычно при использовании portlet контекста).
        Действует, только если вы используете web-aware ApplicationContext
    - application - Жизненный цикл экземпляра ограничен в пределах ServletContext.
        Действует, только если вы используете web-aware ApplicationContext

!!!!!!!!!!!!!!!
        Для того, чтобы указать область видимости бина, отличный от singleton,
            необходимо добавить аннотацию @Scope("область_видимости") методу объявления бина или классу с аннотацией @Component.
!!!!!!!!!!!!!!

!!!!!
    В случае цикличной зависимости(когда класс А требует экземпляр В, а классу В требуется экземпляр А)
    Spring IoC контейнер обнаруживает её и выбрасывает исключение BeanCurrentlyInCreationException.
!!!!!

2. Композиция объектов! Как передать ссылки на обьект?

3. Spring bean жизненный цикл?
    Для управления контейнером жизненным циклом бина,
        можно реализовать метод afterPropertiesSet() интерфейса InitializingBean и метод destroy() интерфейса DisposableBean.
    Метод afterPropertiesSet() позволяет выполнять какие-либо действий после инициализации всех свойств бина контейнером,
        метод destroy() выполняется при уничтожении бина контейнером.
    Однако их не рекомендуется использовать, поскольку они дублируют код Spring.
    Предпочтительно использовать методы с JSR-250 аннотациями
        @PostConstruct и @PreDestroy.
    Также существует вариант определить аналогичные методы как параметры аннотации @Bean:
        @Bean(initMethod = "initMethod", destroyMethod = "destroyMethod").

    !!**__Создание своего цикла жизни bean'a__**!!

    SmartLifecycle интересен тем, что наследует интерфейс Phased,
        в котором есть метод int getPhase();
    Порядок создания бинов, реализующих этот интерфейс, зависит от возвращаемого методом значения(getPhase) и чем оно меньше,
        тем раньше всех будет создан бин и тем позже он будет разрушен.
         # public interface SmartLifecycle extends Lifecycle, Phased {
             boolean isAutoStartup();
             void stop(Runnable callback);
         }
         #public interface Lifecycle {
              void start();
              void stop();
              boolean isRunning();
          }


4. @Entity жизненый цикл

5. Написать любой пример с JDBC и session

6. Жизненый цикл сервлета
    В случае отсутствия сервлета в контейнере.
    1 Класс сервлета загружается контейнером.
    2 Контейнер создает экземпляр класса сервлета.
    3 Контейнер вызывает метод init().
        Этот метод инициализирует сервлет и вызывается в первую очередь,
            до того, как сервлет сможет обслуживать запросы.
        За весь жизненный цикл метод init() вызывается только один раз.
    4 Обслуживание клиентского запроса.
        Каждый запрос обрабатывается в своем отдельном потоке.
        Контейнер вызывает метод service() для каждого запроса.
        Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий
            этому типу метод для обработки запроса.
        Разработчик сервлета должен предоставить реализацию для этих методов (#doGet#doPost и др.).
        Если поступил запрос, метод для которого не реализован,
            вызывается метод родительского класса и
            обычно завершается возвращением ошибки инициатору запроса.
    5 В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(),
        который снимает сервлет из эксплуатации.
        Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.

7. Протокол HTTP.

8. REST раскажи о нем!

9. Нормальные формы первые три рассказать

10. Уровни изоляции

11. Индексы в БД

12. ACID

13. Написать скрипт создания бд с первичным ключом

14. Написать скрипт удаляющий дубликаты в бд

15. Написать UML для декоратора

16. Написать UML для Strategy

++17. Статическая и динамическая типизация
    В java статическая. Компилятор знает, что Integer это 1,2 или -34;
    И выдаст ошибку если написать Integer i = new Integer(1.2);

++18. чем отличается JRE от JDK?
    JDK = JRE + Средства разработки/отладки
        * для разработки!
    JRE = JVM + классы Java-пакетов (например, утилиты, математика, lang, awt, swing и т.д.) + библиотеки времени выполнения.
        * для запуска!
    JVM = система загрузчика классов + область данных времени выполнения + механизм выполнения.
    Виртуальная машина Java (JVM) - это виртуальная машина, которая запускает байт-коды Java.

++19. Что такое JIT компиляция?
    Just-in-time compilation (JIT, компиляция «на лету») — технология увеличения производительности программных систем,
        использующих !!байт-код!!, путём компиляции байт-кода в машинный код непосредственно во время работы программы.

    Java.class - compilator(javac) - byte code - JIT - no - interpreter (JVM) - OC - hardware(машинный код)
                                                   |                             |
                                                  yes ---------------------------

    !* Байт-код не является машинным кодом какого-либо компьютера и может переноситься на различные компьютерные архитектуры.
    !* Байт-код интерпретируется (исполняется) виртуальной машиной.

++20. Чем в SQL inner отличается от outer?
        Существует три типа join-выражений:
        inner join;
        outer join - может быть left, right и full;
        cross join;

        Предположим, у вас есть две таблицы. Каждая состоит из одного столбца, со следующими значениями:
        A    B
        -    -
        1    3
        2    4
        3    5
        4    6
        Обратите внимание, что (1,2) уникальны для A, (3,4) – общие элементы, а (5,6) уникальны для B.

        Внутреннее соединение, использующее один из эквивалентных запросов, дает пересечение двух таблиц, то есть две строки, общие для каждой из них.
        select * from a INNER JOIN b on a.a = b.b;
        select a.*, b.*  from a, b where a.a = b.b;

        a | b
        --+--
        3 | 3
        4 | 4

        Результат левого внешнего соединения – все строки таблицы A плюс все строки таблицы B, имеющие совпадение со строками таблицы А.
        select * from a LEFT OUTER JOIN b on a.a = b.b;
        select a.*, b.*  from a, b where a.a = b.b(+);

        a |  b
        --+-----
        1 | null
        2 | null
        3 |    3
        4 |    4

        Результат правого внешнего соединения – все строки таблицы В плюс все строки таблицы А, имеющие совпадение со строками таблицы В.
        select * from a RIGHT OUTER JOIN b on a.a = b.b;
        select a.*,b.*  from a,b where a.a(+) = b.b;

        a    |  b
        -----+----
        3    |  3
        4    |  4
        null |  5
        null |  6

        Результат полного внешнего соединения – соединение таблиц A и B, т.е. все строки A и все строки B. Если какой-либо элемент таблицы A не имеет соответствия в таблице B, эта часть B пуста, и наоборот.
        select * from a FULL OUTER JOIN b on a.a = b.b;

        a   |  b
        -----+-----
        1 | null
        2 | null
        3 |    3
        4 |    4
        null |    6
        null |    5

 ++21. HashMap.
     1. Что такое коллизия? 2. как она решается? 3. как происходит вставка обекта?
     4. Какое начальное количество корзин в HashMap?
     5. LoadFactory?

     1.Коллизия - состояния когда   key_object1.equals(key_object2) = false, но hashCode'ы равны!!!
     2.1. Обьект добавляется в список в корзине - метод цепочек!
     2.2. Обьект добавляется в открытое-свободное место - метод открытой адресации.

     3. Первое – от ключа находим hashCode и корзину для вставки.
        Затем проверяем, есть ли в корзине уже какие-то объекты, если нет – то добавляем текущий.
        Если да, то это случилась коллизия.
            Тогда мы начинаем сравнивать ключ и hashcode текущего объекта и тех которые внутри.
                Сначала проверяем равны ли hashcode ключей.
                    Если да, то сравниваем их ключ методом equals.
                        Если equals возвращает true, значит ключи совпадают по “значению” и hashcode – производится замена,
                           новый объект заменяет тот который уже там находится под тем же ключом.
                        Если hashcode и “значение” ключа неравны – новый объект добавляется в конец списка.

     4. Начальное количество 16 по default, но можно задать любое свое через конструктор!
     5. HashMap имеет поле loadFactor.
     Оно может быть задано через конструктор.
     По умолчанию равняется 0.75.
     Его произведение на количество корзин дает нам необходимое число объектов,
        которое нужно добавить, чтобы состоялось удвоение количества корзин.

++22. try без catch() возможно?
    /22/
    Да.
        try {
            System.err.println("try");
        } finally {
            System.err.println("finally");
        }

++23. Что такое this?
    this - это указатель на экземпляр класса в котором это слово написано.

++24. Какие изменения в java 8?

 1. Методы интерфейсов по умолчанию #interface MyPerson{ "default!" String crazyHold(){return 7.4;}}
 2. Лямбда выражения - Collection.sort(names, (String a, String b) ->
            { return b.compareTo(a);
            )};// можно без {}!
    где names - это List string'ов!
 3. @FunctionalInterface - has one abstract method!
    Каждой лябмде соответствует тип представленный интерфейсом!
 4.1 Ссылки на методы - Integer::valueOf(передача ссылки на статический метод)
                                                вместо Integer.valueOf(from);
 4.2 PersonFactory<P extends Person> {
       P create(String firstName, LastName);
    }
     PersonFactory<Person> factory = Person::new;// Ссылки на конструктор! Person это класс
     Person p = factory.create("Tony", "Masket");
 5. Появилояь много новых функциональных интерфейсов!
    -Предикаты - Predicate
    -Функции - Function
    -Поставщики - Suppliers
    -Потребители - Consumers
    -Компараторы были но добавились новые методы по умолчанию.
 6. Потоки java.util.Stream и parallelSrtream
        Добавились промежуточные и конечные операции.
        Filter, Sorted, Map - промежуточные операции.
 7. Новое API работы с датами!
 8. Аннотации.
    @interface Hints {
        Hint[] value();
    }
    @Repeatable(Hint.class)
    @interface Hint {
        String value();
    }