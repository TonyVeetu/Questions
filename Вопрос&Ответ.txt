#Список вопросов и ответов
    time fot work - 1,2,3,4,5
++1. Что будет выведено на печать?
class Base{
    private void print{ System.out.println(1); }
}

class Ch extends Base{
    @Override
    private void print{ System.out.println(2); }

    public static void main(){
        Base obj = new Ch();
        ch.print();
    }
}

    /1/ Будет выведено 2.
    Аннотация @Override указывает, что далее мы собираемся переопределять метод базового класса.
    Аннотация служит лишь для контроля успешности действия при сборке проекта.
    В случае отсутствия данной аннотации и не совпадении сигнатур (в результате ошибки) с методом,
    который мы собирались переопределять - случится страшное.
    Очень трудноуловимая ошибка, когда вы думаете, что должно бы переопределяться,
    а по факту имеете отдельный независимый метод, который скорее всего вообще не выполняется.
    При этом компилятор считает, что с его точки зрения все в порядке
    - хотите собственный метод в классе-наследнике - нет проблем. И молчит.

++2. Виды Exceptions. Что такое checked и unchecked? Привести примеры!
    /2/
                        Object
                          |
                   Throwable(CHECKED)
                   /            \
         Error(UNCHECKED)    Exception(CHECKED)
                                |
                      RuntimeException(UNCHECKED)

    1.1 Checked - проверенные, т.к. проверяются перед компиляцией программы, то есть по-любому проверятся.
    #Например, если мы в программе пытаемся считать несуществующий файл, то она выбросил FileNotFoundException.
    Такое можно проверить до компиляции, поэтому и Checked.
    1.2 Exception – это проверенные исключения.
    Это значит, что если метод бросает исключение, которое унаследовано от Exception (напр. IOException), то этот метод должен быть обязательно заключен в блок try-catch.
    Сам метод, который бросает исключение, должен в сигнатуре содержать конструкцию throws.
    Проверенные (checked) исключения означают, что исключение можно было предвидеть и, соответственно,
    оно должно быть обработано, работа приложения должна быть продолжена.
    Пример такого исключения — это попытка создать новый файл, который уже существует (IOException).

    2.1 Unchecked проверить до компиляции нельзя. #Например, у нас есть некое математическое выражение a/(b-c).
    при этом до компиляции неизвестны значения переменных.
    А уже в процессе исполнения программы выяснится, что b = c, и получится, что нужно будет делить "a" на ноль.
    В таком случае вылезет ArithmeticException.
    Но его никак нельзя проверить до исполнения программы, поэтому и unchecked.
    #Еще пример NullPointerException!
    2.2 RuntimeException – это непроверенные исключения.
    Они возникают во время выполнения приложения.
    К таким исключениям относится, например, NullPointerException.
    Они не требуют обязательного заключения в блок try-catch.
    Когда RuntimeException возникает, это свидетельствует о ошибке,
    допущенной программистом (неинициализированный объект, выход за пределы массива и т.д.).
    Поэтому данное исключение не нужно обрабатывать, а нужно исправлять ошибку в коде, чтобы исключение вновь не возникало.

    3.1 Error – критические ошибки, который могут возникнуть в системе (например, StackOverflowError ).
    Как правило обрабатывает их система.
    Если они возникают, то приложение закрывается, так как при данной ситуации работа не может быть продолжена.
    3.2 Из Error'ов стоит знать наиболее общеизвестные, это:
            - OutOfMemoryError (кончилась память)
            - AssertionError (ошибка в условии оператора assert, начиная с Java 1.4)
            - ThreadDeath (кидается в останавливаемом потоке, при вызове у него метода stop()
            - NoSuchMethodError (обычно отсутствует метод main)
            - NoClassDefFoundError (отсутствует код загружаемого класса)

++3. Виды коллекций.
    /3/
    3.1 Интерфейс Collection является самым главным для классов коллекций в библиотеке Java.
    Два основных метода интерфейса.
        - boolean add(E element)
        - Iterator<E> iterator()

    3.2 Коллекции содержат только один элемент в каждой ячейке.
    Список (List) -  где в определенной последовательности хранится группа элементов.
    Множество (Set), в которое можно добавлять только по одному элементу определённого типа.
    Очередь (Queue).

                Interfaces
             /      |       \
    #    Set,      List,     Queue
         |          |           |
      HashSet    ArrayList  PriorityQueue
      TreeSet    Vector     SynchroniseQueue
    LinkedHashSet

    # ArrayList - Механизм автоматического «расширения» массива существует,
    а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().
    #Map не входит в коллекции!

4. Как работают Set, List, Map?
    /4/
    4.1 Set (Множество) - коллекция, которая не может содержать повторяющихся одинаковых элементов, иногда называемая множеством.
    Более формально, коллекция не может содержать пары элементов e1 и e2 таких,
    что выполняется условие e1.equals(e2) и не более одного null элемента

    # При попытке добавлении существующего элемента в LinkedHashSet Коллекция не изменяется
        и все элементы остаются на своих местах.
    # Особое внимание необходимо уделить элементам, которые могут изменяться.
    В поведении Set не указано, что делать если значение элемента Set изменилось таким образом,
    что объект стал равен другому объекту из множества.
    # Некоторые реализации Set имеют ограничения на элементы, которые они могут содержать.
        Например, в некоторых множествах не разрешено добавление null элементов.
        При попытке добавления null в коллекцию обычно происходит unchecked исключение NullPointerException или ClassCastException.

    # HashSet хранит элементы в хеш-таблице, из-за чего имеет наиболее высокую производительность,
        но не гарантирует порядок элементов;
      TreeSet хранит элементы в отсортированном порядке, из-за чего работает существенно медленнее,
        чем HashSet;
      LinkedHashSet отличается от HashSet тем, что хранит элементы в порядке их вставки в коллекцию.
        Эта коллекция лишь немного медленнее HashSet.

    4.2 List


5. Отличия между LinkedList и ArrayList.
6. Отличия между Set и LinkedList.
7. Что будет, если в Set и List добавить по два одинаковых элемента?
8. Отличия между HashMap и и TreeMap.
9. Что нужно сделать, чтобы созданный самим объект использовать в качестве ключа HashMap?
10. Для чего нужно переопределять методы hash и equals?
11. Как работает try with resources?

++12. Что вернёт функция и почему?
public int func(){
    try(){
        return 1;
    }
    finally{
        return 2;
    }
}
    /12/ вернет 2. Finally всегда выполняется!

13. Что такое String, StringBuffer, StringBuilder?
14. Какими способами можно создать и запустить поток?
15. Суть интерфейса Callable.
16. Как остановить поток?
17. Проблемы многопоточности.
18. Какие приходилось решать задачи с многопоточностью?
19. Для чего служит модификатор volatile?
20. Написать реализацию синглтона с синхронизированной инициализацией.
21. Как создать servlet?
22. С какими модулями спринга работал?
23. Как в спринге создать свой контроллер?
24. Суть MVC.
25. Есть две таблицы. Написать для Hibernate класс, на который будут мапиться данные из
таблицы book
       table autor (id, fio) ; table book(id, title, author_id)

26. С какой версией спринга работал?
27. Что такое Bean? Чем отличается от других объектов?
28. Какими способами можно объявить Bean в спринге?
29. В чём суть IoC?
30. В чём суть DI?
31. Как реализуется внедрение зависимостей?
32. Есть два бина от одного интерфейса. Как конкретизировать, какой бин нужно инжектить?
33. Что такое DispatcherServlet в спринге?
34. Что такое servlet?
35. С какими технологиями хотелось бы работать, что-то новое изучить?